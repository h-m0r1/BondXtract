<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="application-name" content="BondXtract">
    <meta name="description" content="A browser-based tool for exploring and analyzing atomic bonds in crystal structures from CIF format">
    <title>BondXtract</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .file-upload {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        .file-upload.dragover {
            border-color: #4facfe;
            background: #f0f8ff;
        }

        .file-upload input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-family: 'Consolas', 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4facfe;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            font-family: 'Consolas', 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .search-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-family: 'Consolas', 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            cursor: pointer;
            width: 100%;
            transition: transform 0.2s ease;
        }

        .search-btn:hover {
            transform: translateY(-2px);
        }

        .search-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            margin-top: 30px;
        }

        .results h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .bond-list {
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #ddd;
            border-radius: 10px;
        }
        
        .bond-list .bond-item {
            min-width: 900px;
        }
        
        /* responsive */
        @media (max-width: 768px) {
            .bond-item {
                grid-template-columns: 0.2fr 1fr 1fr 0.3fr 0.5fr 1.3fr 0.9fr 0.4fr 0.2fr;
                gap: 8px;
                padding: 8px;
                font-size: 0.8em;
            }
            
            .bond-list .bond-item {
                min-width: 900px;
            }
        }

        .bond-item {
            display: grid;
            grid-template-columns: 0.3fr 1fr 1fr 0.4fr 0.6fr 1.4fr 0.8fr 0.5fr 0.25fr;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid #eee;
            align-items: start;
            transition: background-color 0.2s ease;
            font-size: 0.9em;
        }

        .bond-item:hover {
            background-color: #f8f9fa;
        }

        .bond-item:last-child {
            border-bottom: none;
        }

        .bond-header {
            font-weight: bold;
            background: #4facfe;
            color: white;
            border-radius: 10px 10px 0 0;
        }

        .distance {
            font-weight: bold;
            color: #667eea;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .spinner-small {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4facfe;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            margin: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #ffe6e6;
            color: #d63031;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #d63031;
        }

        .info {
            background: #e6f3ff;
            color: #0984e3;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #0984e3;
        }

        .crystal-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .crystal-info h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .crystal-info p {
            margin: 5px 0;
            color: #666;
        }

        .progress-message {
            background: #f8f9fa;
            border-left: 3px solid #4facfe;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 0 5px 5px 0;
            font-size: 0.9em;
            color: #333;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #progressMessages {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border-radius: 5px;
            padding: 10px;
            border: 1px solid #ddd;
        }

        .atom-list-container {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }

        .atom-list-container h4 {
            color: #333;
            margin-bottom: 15px;
            border-bottom: 2px solid #4facfe;
            padding-bottom: 5px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 10px 0;
            margin-top: -15px;
            margin-left: -15px;
            margin-right: -15px;
            padding-left: 15px;
            padding-right: 15px;
        }

        .atom-symbol-group {
            margin-bottom: 25px;
        }

        .atom-symbol-group h5 {
            color: #4facfe;
            margin-bottom: 10px;
            font-size: 1.1em;
            position: sticky;
            top: 50px;
            background: white;
            z-index: 5;
            padding: 5px 0;
        }

        .atom-table-container {
            overflow-x: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
        }

        .atom-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .atom-table th {
            background: #4facfe;
            color: white;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
        }

        .atom-table td {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .atom-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .atom-table tr:hover {
            background: #e3f2fd;
        }

        .atom-table td:last-child {
            font-weight: 600;
        }

        .atom-table td:last-child:contains('Original') {
            color: #27ae60;
        }

        .atom-table td:last-child:contains('Generated by Symmetry') {
            color: #e67e22;
        }

        .download-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 20px;
            font-size: 1em;
            font-family: 'Consolas', 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.2s ease;
        }

        .download-btn:hover {
            transform: translateY(-2px);
        }

        .download-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úº BondXtract</h1>
            <p>Explore and analyze atomic bonds from crystal structure files</p>
            <p style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;" id="versionDisplay">Version Loading...</p>
        </div>

        <div class="main-content">
            <div class="file-upload" id="fileUpload">
                <p>üìÅ Drag & drop a CIF file or click to select</p>
                <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                    üí° Symmetry operations are automatically loaded for detected space group numbers, but the embedded operation sets are based on standard setting and origin choice 1. Different axis orientations or origin choices may require different operations.
                </p>
                <input type="file" id="fileInput" accept=".cif">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Select File
                </button>
            </div>

            <div id="fileParseLog" class="crystal-info" style="display: none;">
                <h4>üìù File Parsing Log</h4>
                <div id="parseLogMessages" style="max-height: 300px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; border: 1px solid #ddd;">
                    <!-- Parsing log messages will be displayed here -->
                </div>
            </div>

            <div id="crystalInfo" class="crystal-info" style="display: none;">
                <h4>üìä Crystal Structure Information</h4>
                <div id="crystalDetails"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>üîç Search Conditions</h3>
                    <div class="form-group">
                        <label for="atom1">Atom 1:</label>
                        <select id="atom1">
                            <option value="">Please select</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="atom2">Atom 2:</label>
                        <select id="atom2">
                            <option value="">Please select</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üìè Distance Range</h3>
                    <div class="form-group">
                        <label for="minDistance">Minimum Distance (√Ö):</label>
                        <input type="number" id="minDistance" step="0.1" min="0" value="1.0">
                    </div>
                    <div class="form-group">
                        <label for="maxDistance">Maximum Distance (√Ö):</label>
                        <input type="number" id="maxDistance" step="0.1" min="0" value="5.0">
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <button class="search-btn" id="searchBtn" onclick="searchBonds()" disabled>
                    Search Bonds
                </button>
                <button class="search-btn" id="stopBtn" onclick="stopSearch()" style="display: none; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                    ‚èπÔ∏è Stop Search
                </button>
            </div>

            <div id="results" class="results" style="display: none;">
                <h3 id="searchStatusTitle">üîç Search in progress...</h3>
                <div id="progressMessages" style="max-height: 200px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; border: 1px solid #ddd; margin-bottom: 20px;">
                    <!-- Progress messages will be displayed here -->
                </div>
                <h4 id="bondResultsTitle" style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #4facfe; padding-bottom: 5px; display: none;">
                    üìä Bond Analysis Results
                </h4>
                <div id="displayControls" style="margin-bottom: 15px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; background: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
                        <label for="uniqueOnlyToggle" style="font-weight: 600; color: #333; margin: 0;">
                            <input type="checkbox" id="uniqueOnlyToggle" style="margin-right: 8px; transform: scale(1.2);">
                            Show unique bonds only
                        </label>
                        <span id="bondCountInfo" style="color: #666; font-size: 0.9em; margin-left: 10px;">
                            (Showing all bonds)
                        </span>
                    </div>
                </div>
                <div id="bondList" class="bond-list"></div>
                <button id="downloadBtn" class="download-btn" onclick="downloadResults()" style="display: none;">
                    üíæ Download Results (CSV)
                </button>
            </div>
        </div>
        
        <div style="text-align: center; padding: 20px; background: #f8f9fa; border-top: 1px solid #ddd; color: #666; font-size: 0.9em;">
            <p id="footerVersion">‚úº BondXtract - Loading...</p>
            <p style="margin-top: 5px; font-size: 0.8em;">A browser-based tool for exploring and analyzing atomic bonds in crystal structures</p>
            <p style="margin-top: 10px; font-size: 0.75em; color: #999;">¬© 2025 Hitoshi Mori. MIT License.</p>
        </div>
    </div>


    
    <script>
        // ========================================
        // VERSION INFORMATION - EDIT ONLY HERE
        // ========================================
        const APP_VERSION = '0.1';
        const APP_NAME = 'BondXtract';
        const APP_DESCRIPTION = 'Crystal Structure Bond Analysis Tool';
        // ========================================
        
        // Initialize version display on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Update page title
            document.title = `${APP_NAME} v${APP_VERSION}`;
            
            // Update meta version tag
            let metaVersion = document.querySelector('meta[name="version"]');
            if (!metaVersion) {
                metaVersion = document.createElement('meta');
                metaVersion.name = 'version';
                document.head.appendChild(metaVersion);
            }
            metaVersion.content = APP_VERSION;
            
            // Update header version display
            const versionDisplay = document.getElementById('versionDisplay');
            if (versionDisplay) {
                versionDisplay.textContent = `Version ${APP_VERSION}`;
            }
            
            // Update footer version display
            const footerVersion = document.getElementById('footerVersion');
            if (footerVersion) {
                footerVersion.textContent = `‚úº ${APP_NAME} v${APP_VERSION} - ${APP_DESCRIPTION}`;
            }
        });
        
        // Log version information to console
        console.log(`${APP_NAME} v${APP_VERSION} - ${APP_DESCRIPTION}`);
        
        let crystalData = null;
        let atoms = [];
        let currentWorker = null; // Currently running Web Worker
        let isSearching = false; // Flag indicating if search is in progress
        let currentBonds = []; // Store current search results
        // Save maxUniqueID for all bonds and unique bonds
        let maxUIDAllBonds = 0;
        let maxUIDUniqueBonds = 0;
        
        // Memory management for large datasets
        let memoryUsage = {
            atomDataSize: 0,
            bondDataSize: 0,
            lastCleanup: Date.now()
        };
        
        // Memory cleanup function
        function cleanupMemory() {
            const now = Date.now();
            if (now - memoryUsage.lastCleanup > 30000) { // Cleanup every 30 seconds
                // Check if we're in Node.js environment with global.gc available
                if (typeof global !== 'undefined' && global.gc) {
                    global.gc(); // Force garbage collection if available
                }
                memoryUsage.lastCleanup = now;
                console.log('Memory cleanup performed');
            }
        }

        // Covalent radius data (defined once in global scope)
        const covalentRadii = {
            'H': 0.31, 'He': 0.28, 'Li': 1.28, 'Be': 0.96, 'B': 0.84, 'C': 0.76, 'N': 0.71, 'O': 0.66, 'F': 0.57, 'Ne': 0.58,
            'Na': 1.66, 'Mg': 1.41, 'Al': 1.21, 'Si': 1.11, 'P': 1.07, 'S': 1.05, 'Cl': 1.02, 'Ar': 1.06,
            'K': 2.03, 'Ca': 1.76, 'Sc': 1.70, 'Ti': 1.60, 'V': 1.53, 'Cr': 1.39, 'Mn': 1.39, 'Fe': 1.32, 'Co': 1.26, 'Ni': 1.24, 'Cu': 1.32, 'Zn': 1.22,
            'Ga': 1.22, 'Ge': 1.20, 'As': 1.19, 'Se': 1.20, 'Br': 1.20, 'Kr': 1.16,
            'Rb': 2.20, 'Sr': 1.95, 'Y': 1.90, 'Zr': 1.75, 'Nb': 1.64, 'Mo': 1.54, 'Tc': 1.47, 'Ru': 1.46, 'Rh': 1.42, 'Pd': 1.39, 'Ag': 1.45, 'Cd': 1.44,
            'In': 1.42, 'Sn': 1.39, 'Sb': 1.39, 'Te': 1.38, 'I': 1.39, 'Xe': 1.40,
            'Cs': 2.44, 'Ba': 2.15, 'La': 2.07, 'Ce': 2.04, 'Pr': 2.03, 'Nd': 2.01, 'Pm': 1.99, 'Sm': 1.98, 'Eu': 1.98, 'Gd': 1.96, 'Tb': 1.94, 'Dy': 1.92, 'Ho': 1.92, 'Er': 1.89, 'Tm': 1.90, 'Yb': 1.87, 'Lu': 1.87,
            'Hf': 1.75, 'Ta': 1.70, 'W': 1.62, 'Re': 1.51, 'Os': 1.44, 'Ir': 1.41, 'Pt': 1.36, 'Au': 1.36, 'Hg': 1.32, 'Tl': 1.45, 'Pb': 1.46, 'Bi': 1.48, 'Po': 1.40, 'At': 1.50, 'Rn': 1.50
        };

        // Global variable: store loaded JSON files
        let loadedSpaceGroupData = {};
        
        // File upload processing
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        
        // Keyboard shortcut (Esc key to stop search)
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && isSearching) {
                stopSearch();
            }
        });
        
        // Unique bonds only toggle event listener
        document.addEventListener('DOMContentLoaded', function() {
            const uniqueOnlyToggle = document.getElementById('uniqueOnlyToggle');
            if (uniqueOnlyToggle) {
                uniqueOnlyToggle.addEventListener('change', function() {
                    console.log('Toggle changed:', this.checked);
                    updateBondDisplay();
                });
            }
        });
        
        const fileUpload = document.getElementById('fileUpload');
        
        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUpload.classList.add('dragover');
        });
        
        fileUpload.addEventListener('dragleave', () => {
            fileUpload.classList.remove('dragover');
        });
        
        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUpload.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileSelect(event) {
            console.log('handleFileSelect called');
            const file = event.target.files[0];
            console.log('Selected file:', file);
            if (file) {
                handleFile(file);
            } else {
                console.log('No file selected');
            }
        }

        // Function to clear all previous data and UI elements
        function clearAllPreviousData() {
            console.log('Clearing all previous data...');
            
            // Clear global variables
            crystalData = null;
            atoms = [];
            currentBonds = [];
            currentWorker = null;
            isSearching = false;
            maxUIDAllBonds = 0;
            maxUIDUniqueBonds = 0;
            
            // Reset warning flag
            window.bondWarningShown = false;
            
            // Clear memory usage tracking
            memoryUsage = {
                atomDataSize: 0,
                bondDataSize: 0,
                lastCleanup: Date.now()
            };
            
            // Clear and hide UI elements
            const crystalInfo = document.getElementById('crystalInfo');
            if (crystalInfo) {
                crystalInfo.style.display = 'none';
                const crystalDetails = document.getElementById('crystalDetails');
                if (crystalDetails) crystalDetails.innerHTML = '';
            }
            
            // Clear atom list container
            const atomListContainer = document.getElementById('atomListContainer');
            if (atomListContainer) {
                atomListContainer.remove();
            }
            
            // Clear file parsing log
            clearParseLog();
            
            // Clear results area
            const results = document.getElementById('results');
            if (results) {
                results.style.display = 'none';
                results.innerHTML = `
                    <h3 id="searchStatusTitle">üîç Search in progress...</h3>
                    <div id="progressMessages" style="max-height: 200px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; border: 1px solid #ddd; margin-bottom: 20px;">
                    </div>
                    <h4 id="bondResultsTitle" style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #4facfe; padding-bottom: 5px; display: none;">
                        üìä Bond Analysis Results
                    </h4>
                    <div id="displayControls" style="margin-bottom: 15px; display: none;">
                        <div style="display: flex; align-items: center; gap: 10px; background: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
                            <label for="uniqueOnlyToggle" style="font-weight: 600; color: #333; margin: 0;">
                                <input type="checkbox" id="uniqueOnlyToggle" style="margin-right: 8px; transform: scale(1.2);">
                                Show unique bonds only
                            </label>
                            <span id="bondCountInfo" style="color: #666; font-size: 0.9em; margin-left: 10px;">
                                (Showing all bonds)
                            </span>
                        </div>
                    </div>
                    <div id="bondList" class="bond-list"></div>
                    <button id="downloadBtn" class="download-btn" onclick="downloadResults()" style="display: none;">
                        üíæ Download Results (CSV)
                    </button>
                `;
            }
            
            // Reset atom select options
            const atom1Select = document.getElementById('atom1');
            const atom2Select = document.getElementById('atom2');
            if (atom1Select) {
                atom1Select.innerHTML = '<option value="">Please select</option>';
            }
            if (atom2Select) {
                atom2Select.innerHTML = '<option value="">Please select</option>';
            }
            
            // Disable search button
            const searchBtn = document.getElementById('searchBtn');
            if (searchBtn) {
                searchBtn.disabled = true;
            }
            
            // Reset search buttons
            updateSearchButtons();
            
            // Remove any existing error/info messages
            const existingMessages = document.querySelectorAll('.error, .info');
            existingMessages.forEach(msg => msg.remove());
            
            // Remove bond warning if exists
            const bondWarning = document.getElementById('bondWarningBox');
            if (bondWarning) {
                bondWarning.remove();
            }
            
            // Force garbage collection if available
            cleanupMemory();
            
            console.log('All previous data cleared successfully');
        }

        async function handleFile(file) {
            console.log('handleFile called with file:', file.name);
            
            // Clear all previous data before processing new file
            clearAllPreviousData();
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                console.log('File read successfully, content length:', e.target.result.length);
                const content = e.target.result;
                await parseCIF(content);
            };
            reader.onerror = function(e) {
                console.error('Error reading file:', e);
                showError('An error occurred while reading the file: ' + e.message);
            };
            reader.readAsText(file);
        }



        // Function to parse symmetry operations
        async function parseSymmetryOperations(lines) {
            const symmetryOps = [];
            let hasSymmetryData = false;
            let usedAlternativeKeyword = false;
            let symmetryKeyword = '';
            let bothKeywordsNotFound = false;
            
            // Internal function to parse symmetry operations (new algorithm)
            function parseSymmetryLoop(targetKeyword) {
                const ops = [];
                
                // 1. Detect loop_ from top to bottom of file
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line === 'loop_') {
                        console.log(`loop_ detected: line ${i + 1}`);
                        
                        // 2. Detect blank lines that appear after this line
                        let blockEndIndex = -1;
                        for (let j = i + 1; j < lines.length; j++) {
                            if (lines[j].trim() === '') {
                                blockEndIndex = j;
                                console.log(`Blank line detected: line ${j + 1} (block end)`);
                                break;
                            }
                        }
                        
                        // If no blank line is found, treat until end of file
                        if (blockEndIndex === -1) {
                            blockEndIndex = lines.length;
                            console.log(`Treating until end of file as block`);
                        }
                        
                        // 3. Data existing between them corresponds to list block
                        const blockLines = lines.slice(i + 1, blockEndIndex);
                        console.log(`Block line count: ${blockLines.length}`);
                        
                        // Recognize header section
                        const headers = [];
                        let dataStartIndex = -1;
                        
                        for (let k = 0; k < blockLines.length; k++) {
                            const blockLine = blockLines[k].trim();
                            
                                                    if (blockLine.startsWith('_')) {
                            // Header line
                            headers.push(blockLine);
                            console.log(`Header line detected: "${blockLine}"`);
                        } else if (blockLine && !blockLine.startsWith('loop_')) {
                            // Start of data row
                            dataStartIndex = k;
                            console.log(`Data row start: line ${k + 1} "${blockLine}"`);
                            break;
                        }
                        }
                        
                        // 4. If the target tag does not exist in the header section, detect the next loop_
                        const targetHeaderIndex = headers.indexOf(targetKeyword);
                        if (targetHeaderIndex === -1) {
                            console.log(`Target tag "${targetKeyword}" not found. Searching for next loop_.`);
                            continue;
                        }
                        
                        console.log(`Target tag "${targetKeyword}" detected: column position ${targetHeaderIndex}`);
                        
                        // Parse data rows
                        if (dataStartIndex !== -1) {
                            for (let k = dataStartIndex; k < blockLines.length; k++) {
                                const dataLine = blockLines[k].trim();
                                
                                if (dataLine && !dataLine.startsWith('_') && !dataLine.startsWith('loop_')) {
                                                                    console.log(`Parsing data line: "${dataLine}"`);
                                
                                // Single symmetry operation case (quoted line)
                                if (dataLine.startsWith("'") && dataLine.endsWith("'")) {
                                    const cleanOperation = dataLine.replace(/['"]/g, '');
                                    ops.push(cleanOperation);
                                    console.log(`Added symmetry operation: "${cleanOperation}"`);
                                } else {
                                    // Multi-column case parsing
                                    const elements = parseCIFLine(dataLine);
                                    if (elements.length > targetHeaderIndex) {
                                        const operation = elements[targetHeaderIndex];
                                        if (operation && operation.startsWith("'") && operation.endsWith("'")) {
                                            const cleanOperation = operation.replace(/['"]/g, '');
                                            ops.push(cleanOperation);
                                            console.log(`Added symmetry operation: "${cleanOperation}"`);
                                        } else {
                                            console.log(`Skipping element not recognized as symmetry operation: "${operation}"`);
                                        }
                                    }
                                }
                                }
                            }
                        }
                        
                        // Exit if symmetry operations are found
                        if (ops.length > 0) {
                            console.log(`Detected ${ops.length} symmetry operations. Ending parsing.`);
                            break;
                        }
                    }
                }
                
                console.log(`parseSymmetryLoop result: ${ops.length} symmetry operations detected`);
                return ops;
            }
            
            // Function to split CIF line into elements (correctly handle quoted elements)
            function parseCIFLine(line) {
                const elements = [];
                let currentElement = '';
                let inQuotes = false;
                let quoteChar = '';
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (!inQuotes && (char === "'" || char === '"')) {
                        // start of quote
                        inQuotes = true;
                        quoteChar = char;
                        currentElement += char;
                    } else if (inQuotes && char === quoteChar) {
                        // end of quote
                        inQuotes = false;
                        currentElement += char;
                    } else if (!inQuotes && /\s/.test(char)) {
                        // separate elements by whitespace (only if not in quotes)
                        if (currentElement.trim()) {
                            elements.push(currentElement.trim());
                            currentElement = '';
                        }
                    } else {
                        // normal character
                        currentElement += char;
                    }
                }
                
                // add last element
                if (currentElement.trim()) {
                    elements.push(currentElement.trim());
                }
                
                return elements;
            }
            
            // first search _space_group_symop_operation_xyz (priority)
            console.log('Searching for _space_group_symop_operation_xyz in CIF file...');
            const primaryOps = parseSymmetryLoop('_space_group_symop_operation_xyz');
            if (primaryOps.length > 0) {
                symmetryOps.push(...primaryOps);
                hasSymmetryData = true;
                symmetryKeyword = '_space_group_symop_operation_xyz';
                console.log('‚úÖ Symmetry operations detected in CIF file using _space_group_symop_operation_xyz (priority use)');
                addParseLog(`Using symmetry operation data from CIF file (_space_group_symop_operation_xyz: ${primaryOps.length} operations)`, 'success');
            }
            
            // If _space_group_symop_operation_xyz is not found, search for _symmetry_equiv_pos_as_xyz
            if (!hasSymmetryData) {
                console.log('_space_group_symop_operation_xyz not found. Searching for _symmetry_equiv_pos_as_xyz...');
                const alternativeOps = parseSymmetryLoop('_symmetry_equiv_pos_as_xyz');
                if (alternativeOps.length > 0) {
                    symmetryOps.push(...alternativeOps);
                    hasSymmetryData = true;
                    usedAlternativeKeyword = true;
                    symmetryKeyword = '_symmetry_equiv_pos_as_xyz';
                    console.log('‚úÖ Symmetry operations detected in CIF file using _symmetry_equiv_pos_as_xyz (alternative keyword)');
                    addParseLog(`Using symmetry operation data from CIF file (_symmetry_equiv_pos_as_xyz: ${alternativeOps.length} items)`, 'success');
                } else {
                    console.log('_symmetry_equiv_pos_as_xyz also not found in CIF file.');
                    bothKeywordsNotFound = true;
                }
            }
            
            console.log(`Number of parsed symmetry operations: ${symmetryOps.length}`);
            console.log('Parsed symmetry operations:', symmetryOps);
            console.log('Used keyword:', symmetryKeyword);
            console.log('Using alternative keyword:', usedAlternativeKeyword);
            
            // Only if no symmetry operation data exists in CIF file, get embedded data from space group number
            if (!hasSymmetryData) {
                console.log('No symmetry operation data found in CIF file. Attempting to get embedded data from space group number...');
                addParseLog('No symmetry operation data found in CIF file. Attempting to get embedded data from space group number...', 'warning');
                console.log('crystalData:', crystalData);
                console.log('crystalData.spaceGroupNumber:', crystalData?.spaceGroupNumber);
                
                // Check if space group number is available
                if (crystalData && crystalData.spaceGroupNumber) {
                    try {
                        const spaceGroupNumber = parseInt(crystalData.spaceGroupNumber);
                        console.log(`Getting symmetry operations from embedded data for space group number ${spaceGroupNumber}...`);
                        addParseLog(`Getting symmetry operations from embedded data for space group number ${spaceGroupNumber}...`, 'info');
                        
                        // Get symmetry operations from embedded data using space group number
                        const operations = await getSymmetryOperationsBySpaceGroupNumber(spaceGroupNumber);
                        
                        if (operations && operations.length > 0) {
                            symmetryOps.push(...operations);
                            hasSymmetryData = true;
                            symmetryKeyword = 'from_embedded_space_group_number';
                            console.log(`Retrieved ${operations.length} symmetry operations from embedded data for space group number ${spaceGroupNumber}`);
                            addParseLog(`Since no symmetry operation data exists in CIF file, retrieved symmetry operations from embedded data for space group number ${spaceGroupNumber} (${operations.length} items)`, 'success');
                        } else {
                            throw new Error(`Embedded data for space group number ${spaceGroupNumber} is empty`);
                        }
                    } catch (error) {
                        console.error('Error getting embedded data from space group number:', error);
                        addParseLog(`Error getting embedded data from space group number: ${error.message}`, 'error');
                        throw new Error(`CIF file contains no symmetry operation information and failed to get from embedded data for space group number ${crystalData.spaceGroupNumber}: ${error.message}`);
                    }
                } else {
                    addParseLog('CIF file contains no space group number information.', 'error');
                    throw new Error('CIF file contains no _space_group_symop_operation_xyz or _symmetry_equiv_pos_as_xyz information, and space group number could not be obtained. Symmetry operation information is required.');
                }
            }
            
            if (symmetryOps.length === 0) {
                throw new Error('Symmetry operation information could not be parsed correctly. Please check the CIF file format.');
            }
            
            // Display warnings based on keyword usage
            if (usedAlternativeKeyword) {
                addParseLog('Note: _space_group_symop_operation_xyz not found, using _symmetry_equiv_pos_as_xyz instead. The recommended keyword is _space_group_symop_operation_xyz.', 'warning');
            }
            
            if (bothKeywordsNotFound) {
                addParseLog('Note: Neither _space_group_symop_operation_xyz nor _symmetry_equiv_pos_as_xyz found in CIF file. The recommended keyword is _space_group_symop_operation_xyz.', 'warning');
            }
            
            return symmetryOps;
        }

        // Function to apply symmetry operation and transform coordinates
        function applySymmetryOperation(x, y, z, operation) {
            // Parse symmetry operation string and transform coordinates
            // Example: '-x, -y, -z' -> (-x, -y, -z)
            // Example: 'x+1/2, y+1/2, z' -> (x+0.5, y+0.5, z)
            // Example: 'y, -x, -z' -> (y, -x, -z)
            
            let newX = 0, newY = 0, newZ = 0;
            
            // Parse each coordinate component
            const parts = operation.split(',').map(part => part.trim());
            
            console.log(`Applying symmetry operation: ${operation}`);
            console.log(`Original coordinates: (${x}, ${y}, ${z})`);
            console.log(`Parsed parts:`, parts);
            
            if (parts.length >= 3) {
                // Process X coordinate (evaluate parts[0] expression)
                newX = evaluateCoordinateExpression(parts[0], x, y, z);
                // Process Y coordinate (evaluate parts[1] expression)
                newY = evaluateCoordinateExpression(parts[1], x, y, z);
                // Process Z coordinate (evaluate parts[2] expression)
                newZ = evaluateCoordinateExpression(parts[2], x, y, z);
            }
            
            // Normalize coordinates to range 0 to less than 1
            newX = normalizeFractionalCoordinate(newX);
            newY = normalizeFractionalCoordinate(newY);
            newZ = normalizeFractionalCoordinate(newZ);
            
            console.log(`Normalized coordinates: (${newX}, ${newY}, ${newZ})`);
            
            return { x: newX, y: newY, z: newZ };
        }

        // Function to evaluate coordinate expressions (supports complex symmetry operations)
        function evaluateCoordinateExpression(expr, x, y, z) {
            console.log(`Evaluating coordinate expression: "${expr}" (coordinate values: x=${x}, y=${y}, z=${z})`);
            
            // Normalize expression (remove whitespace)
            let normalizedExpr = expr.replace(/\s+/g, '');
            
            // Convert fractions to decimals
            normalizedExpr = normalizedExpr.replace(/(\d+)\/(\d+)/g, (match, num, den) => {
                return (parseInt(num) / parseInt(den)).toString();
            });
            
            console.log(`Normalized expression: "${normalizedExpr}"`);
            
            // Replace coordinate variables with numerical values (handle negative signs correctly)
            let resultExpr = normalizedExpr;
            
            // Process negative variables (-x, -y, -z) first
            resultExpr = resultExpr.replace(/-x/g, `(-${x})`);
            resultExpr = resultExpr.replace(/-y/g, `(-${y})`);
            resultExpr = resultExpr.replace(/-z/g, `(-${z})`);
            
            // Process positive variables (x, y, z)
            resultExpr = resultExpr.replace(/x/g, `(${x})`);
            resultExpr = resultExpr.replace(/y/g, `(${y})`);
            resultExpr = resultExpr.replace(/z/g, `(${z})`);
            
            console.log(`Expression after variable substitution: "${resultExpr}"`);
            
            // Sign normalization processing
            resultExpr = normalizeSigns(resultExpr);
            console.log(`Expression after sign normalization: "${resultExpr}"`);
            
            // Verify that normalized expression is not empty
            if (!resultExpr || resultExpr.trim() === '') {
                throw new Error(`Expression became empty after sign normalization: original expression="${expr}"`);
            }
            
            // safe expression evaluation
            try {
                // allow only basic arithmetic operations
                const allowedChars = /^[0-9+\-*/().\s]+$/;
                if (!allowedChars.test(resultExpr)) {
                    throw new Error(`Invalid characters: ${resultExpr}`);
                }
                
                // function evaluation (safe method)
                const result = evaluateArithmeticExpression(resultExpr);
                console.log(`Calculation result: ${result}`);
                return result;
            } catch (error) {
                console.error(`Error evaluating expression: ${error.message}`);
                console.error(`Problematic expression: ${resultExpr}`);
                throw new Error(`Cannot evaluate symmetry operation expression "${expr}": ${error.message}`);
            }
        }
        
        // Function to normalize signs
        function normalizeSigns(expr) {
            let result = expr;
            let previousResult = '';
            let iteration = 0;
            
            console.log(`Starting sign normalization: "${expr}"`);
            
            // Repeat normalization until no changes occur
            while (result !== previousResult && iteration < 10) {
                previousResult = result;
                iteration++;
                
                console.log(`Sign normalization iteration ${iteration}: "${result}"`);
                
                // Normalize consecutive signs
                // ++ ‚Üí +, -- ‚Üí +, +- ‚Üí -, -+ ‚Üí -
                result = result.replace(/\+\+/g, '+');  // Two positive signs ‚Üí one positive sign
                result = result.replace(/--/g, '+');    // Two negative signs ‚Üí one positive sign
                result = result.replace(/\+-/g, '-');   // Positive + negative ‚Üí one negative sign
                result = result.replace(/-\+/g, '-');   // Negative + positive ‚Üí one negative sign
                
                // Also normalize signs within parentheses
                result = result.replace(/\(([^)]*)\)/g, (match, inner) => {
                    let normalizedInner = inner;
                    normalizedInner = normalizedInner.replace(/\+\+/g, '+');
                    normalizedInner = normalizedInner.replace(/--/g, '+');
                    normalizedInner = normalizedInner.replace(/\+-/g, '-');
                    normalizedInner = normalizedInner.replace(/-\+/g, '-');
                    return `(${normalizedInner})`;
                });
            }
            
            // Final normalization: Remove leading single + from numbers (keep + as operator)
            // Remove + at beginning of expression or after operators
            result = result.replace(/^\+(\d)/g, '$1');  // Leading +number ‚Üí number
            result = result.replace(/^\+\.(\d)/g, '.$1');  // Leading +.number ‚Üí .number
            result = result.replace(/([+\-*/])+(\d)/g, '$1$2');  // +number after operator ‚Üí operator+number
            result = result.replace(/([+\-*/])+\.(\d)/g, '$1.$2');  // +.number after operator ‚Üí operator+.number
            
            // Also remove leading + from numbers within parentheses (keep + as operator)
            result = result.replace(/\(([^)]*)\)/g, (match, inner) => {
                let normalizedInner = inner;
                normalizedInner = normalizedInner.replace(/^\+(\d)/g, '$1');  // Leading +number within parentheses
                normalizedInner = normalizedInner.replace(/^\+\.(\d)/g, '.$1');  // Leading +.number within parentheses
                normalizedInner = normalizedInner.replace(/([+\-*/])+(\d)/g, '$1$2');  // +number after operator within parentheses
                normalizedInner = normalizedInner.replace(/([+\-*/])+\.(\d)/g, '$1.$2');  // +.number after operator within parentheses
                return `(${normalizedInner})`;
            });
            
            console.log(`Sign normalization complete: "${result}"`);
            return result;
        }
        
        // Safe arithmetic expression evaluation function
        function evaluateArithmeticExpression(expr) {
            // Function to process parentheses
            function evaluateParentheses(expr) {
                const stack = [];
                const result = [];
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    if (char === '(') {
                        stack.push(i);
                    } else if (char === ')') {
                        if (stack.length === 0) {
                            throw new Error('Invalid parenthesis matching');
                        }
                        const start = stack.pop();
                        if (stack.length === 0) {
                            // Evaluate outermost parentheses
                            const innerExpr = expr.substring(start + 1, i);
                            const innerResult = evaluateArithmeticExpression(innerExpr);
                            result.push(innerResult);
                        }
                    } else if (stack.length === 0) {
                        result.push(char);
                    }
                }
                
                if (stack.length > 0) {
                    throw new Error('Unclosed parentheses');
                }
                
                return result.join('');
            }
            
            // Function to process multiplication and division
            function evaluateMultiplicationDivision(expr) {
                // More accurate token splitting (correctly recognize negative numbers)
                const tokens = [];
                let current = '';
                let inNumber = false;
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    
                    if (/\d/.test(char) || char === '.') {
                        // number or decimal point
                        current += char;
                        inNumber = true;
                    } else if (char === '-' && !inNumber && (i === 0 || /[+\-*/]/.test(expr[i-1]))) {
                        // negative sign (start of number)
                        current = char;
                        inNumber = true;
                    } else if (/[+\-*/]/.test(char)) {
                        // operator
                        if (current) {
                            tokens.push(current);
                            current = '';
                            inNumber = false;
                        }
                        tokens.push(char);
                    } else if (char === '(' || char === ')') {
                        // parentheses
                        if (current) {
                            tokens.push(current);
                            current = '';
                            inNumber = false;
                        }
                        tokens.push(char);
                    } else if (/\s/.test(char)) {
                        // whitespace
                        if (current) {
                            tokens.push(current);
                            current = '';
                            inNumber = false;
                        }
                    }
                }
                
                if (current) {
                    tokens.push(current);
                }
                
                console.log(`Tokens before multiplication/division processing:`, tokens);
                
                const result = [];
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    if (token === '*' || token === '/') {
                        if (i === 0 || i === tokens.length - 1) {
                            throw new Error('Invalid operator position');
                        }
                        
                        const prev = parseFloat(result.pop());
                        const next = parseFloat(tokens[i + 1]);
                        
                        if (isNaN(prev) || isNaN(next)) {
                            throw new Error(`Failed to parse numbers: prev=${prev}, next=${next}`);
                        }
                        
                        let operationResult;
                        if (token === '*') {
                            operationResult = prev * next;
                        } else if (token === '/') {
                            if (next === 0) {
                                throw new Error('Division by zero');
                            }
                            operationResult = prev / next;
                        }
                        
                        result.push(operationResult.toString());
                        i++; // Skip next token
                    } else {
                        result.push(token);
                    }
                }
                
                console.log(`Tokens after multiplication/division processing:`, result);
                return result.join('');
            }
            
            // Function to process addition and subtraction
            function evaluateAdditionSubtraction(expr) {
                // More accurate token splitting
                const tokens = [];
                let current = '';
                let inNumber = false;
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    
                    if (/\d/.test(char) || char === '.') {
                        // number or decimal point
                        current += char;
                        inNumber = true;
                    } else if (char === '-' && !inNumber && (i === 0 || /[+\-]/.test(expr[i-1]))) {
                        // negative sign (start of number)
                        current = char;
                        inNumber = true;
                    } else if (/[+\-]/.test(char)) {
                        // operator
                        if (current) {
                            tokens.push(current);
                            current = '';
                            inNumber = false;
                        }
                        tokens.push(char);
                    } else if (/\s/.test(char)) {
                        // whitespace
                        if (current) {
                            tokens.push(current);
                            current = '';
                            inNumber = false;
                        }
                    }
                }
                
                if (current) {
                    tokens.push(current);
                }
                
                console.log(`Tokens before addition/subtraction processing:`, tokens);
                
                if (tokens.length === 0) {
                    return 0;
                }
                
                let result = parseFloat(tokens[0]) || 0;
                
                for (let i = 1; i < tokens.length; i += 2) {
                    const operator = tokens[i];
                    
                    if (i + 1 >= tokens.length) {
                        throw new Error(`Missing operand for operator "${operator}"`);
                    }
                    
                    const operand = parseFloat(tokens[i + 1]);
                    
                    if (isNaN(operand)) {
                        throw new Error(`Failed to parse number: operand=${tokens[i + 1]}, tokens=${JSON.stringify(tokens)}`);
                    }
                    
                    if (operator === '+') {
                        result += operand;
                    } else if (operator === '-') {
                        result -= operand;
                    } else {
                        throw new Error(`Invalid operator: ${operator}`);
                    }
                }
                
                console.log(`Addition/subtraction processing result: ${result}`);
                return result;
            }
            
            // Evaluate expression step by step
            let processedExpr = evaluateParentheses(expr);
            processedExpr = evaluateMultiplicationDivision(processedExpr);
            const result = evaluateAdditionSubtraction(processedExpr);
            
            return result;
        }

        // Function to normalize fractional coordinates to range 0 to less than 1
        function normalizeFractionalCoordinate(coord) {
            // Normalize coordinates to range 0 to less than 1
            let normalized = coord;
            
            // For negative values, add 1 until positive
            while (normalized < 0) {
                normalized += 1;
            }
            
            // For values >= 1, subtract 1 until less than 1
            while (normalized >= 1) {
                normalized -= 1;
            }
            
            // Consider floating point errors, adjust very small negative values to 0, values very close to 1 to less than 1
            if (Math.abs(normalized) < 1e-10) {
                normalized = 0;
            } else if (Math.abs(normalized - 1) < 1e-10) {
                normalized = 0;
            }
            
            return normalized;
        }

        // Optimized duplicate coordinate checking (deprecated - now handled by OptimizedAtomData)
        function isDuplicateCoordinate(coord1, coord2, tolerance = 0.0002) {
            console.warn('isDuplicateCoordinate is deprecated. Use OptimizedAtomData.isDuplicateCoordinate instead.');
            return Math.abs(coord1.x - coord2.x) <= tolerance &&
                   Math.abs(coord1.y - coord2.y) <= tolerance &&
                   Math.abs(coord1.z - coord2.z) <= tolerance;
        }

        // Optimized atom data structure with pre-computed indices
        class OptimizedAtomData {
            constructor() {
                this.atoms = [];
                this.atomsBySymbol = new Map(); // Symbol -> Array of atom indices
                this.atomsByOriginal = new Map(); // original flag -> Array of atom indices
                this.duplicateMap = new Map(); // coordinate hash -> atom index
            }
            
            // Add atom with optimized data structure
            addAtom(atom) {
                const index = this.atoms.length;
                this.atoms.push(atom);
                
                // Update symbol index
                if (!this.atomsBySymbol.has(atom.symbol)) {
                    this.atomsBySymbol.set(atom.symbol, []);
                }
                this.atomsBySymbol.get(atom.symbol).push(index);
                
                // Update original flag index
                const originalKey = atom.original ? 'original' : 'generated';
                if (!this.atomsByOriginal.has(originalKey)) {
                    this.atomsByOriginal.set(originalKey, []);
                }
                this.atomsByOriginal.get(originalKey).push(index);
                
                return index;
            }
            
            // Get atoms by symbol (optimized)
            getAtomsBySymbol(symbol) {
                const indices = this.atomsBySymbol.get(symbol) || [];
                return indices.map(index => this.atoms[index]);
            }
            
            // Get all atoms (optimized)
            getAllAtoms() {
                return this.atoms;
            }
            
            // Check for duplicate coordinates (optimized)
            isDuplicateCoordinate(coords, tolerance = 0.0002) {
                const hash = this.coordinateHash(coords);
                return this.duplicateMap.has(hash);
            }
            
            // Add coordinate hash for duplicate checking
            addCoordinateHash(coords, atomIndex) {
                const hash = this.coordinateHash(coords);
                this.duplicateMap.set(hash, atomIndex);
            }
            
            // Optimized coordinate hash function
            coordinateHash(coords) {
                // Round to tolerance level for hash
                const precision = 4; // 0.0001 precision
                const x = Math.round(coords.x * Math.pow(10, precision));
                const y = Math.round(coords.y * Math.pow(10, precision));
                const z = Math.round(coords.z * Math.pow(10, precision));
                return `${x},${y},${z}`;
            }
            
            // Get total count
            getCount() {
                return this.atoms.length;
            }
            
            // Clear data for memory optimization
            clear() {
                this.atoms = [];
                this.atomsBySymbol.clear();
                this.atomsByOriginal.clear();
                this.duplicateMap.clear();
            }
        }
        
        // Function to generate atom list by applying symmetry operations (optimized)
        function generateSymmetryEquivalentAtoms(originalAtoms, symmetryOps) {
            const optimizedData = new OptimizedAtomData();
            
            console.log(`\n=== Starting optimized symmetry operation application ===`);
            console.log(`Original atom count: ${originalAtoms.length}`);
            console.log(`Number of symmetry operations: ${symmetryOps.length}`);
            
            // Pre-filter identity operations
            const nonIdentityOps = symmetryOps.filter(op => op !== 'x, y, z');
            console.log(`Non-identity operations: ${nonIdentityOps.length}`);
            
            originalAtoms.forEach((originalAtom, atomIndex) => {
                // Add original atom with normalized coordinates
                const normalizedCoords = {
                    x: normalizeFractionalCoordinate(originalAtom.x),
                    y: normalizeFractionalCoordinate(originalAtom.y),
                    z: normalizeFractionalCoordinate(originalAtom.z)
                };
                
                const originalAtomData = {
                    label: originalAtom.label,
                    occupancy: originalAtom.occupancy,
                    x: normalizedCoords.x,
                    y: normalizedCoords.y,
                    z: normalizedCoords.z,
                    symbol: originalAtom.symbol,
                    original: true
                };
                
                const originalIndex = optimizedData.addAtom(originalAtomData);
                optimizedData.addCoordinateHash(normalizedCoords, originalIndex);
                
                // Apply symmetry operations (optimized)
                nonIdentityOps.forEach((operation, opIndex) => {
                    const newCoords = applySymmetryOperation(originalAtom.x, originalAtom.y, originalAtom.z, operation);
                    
                    // Optimized duplicate check using hash
                    if (!optimizedData.isDuplicateCoordinate(newCoords)) {
                        const newAtom = {
                            label: `${originalAtom.label}_sym${opIndex + 1}`,
                            occupancy: originalAtom.occupancy,
                            x: newCoords.x, // Use symmetry operation result
                            y: newCoords.y,
                            z: newCoords.z,
                            symbol: originalAtom.symbol,
                            original: false,
                            symmetryOp: operation
                        };
                        
                        const newIndex = optimizedData.addAtom(newAtom);
                        optimizedData.addCoordinateHash(newCoords, newIndex);
                    }
                });
            });
            
            console.log(`\n=== Optimized symmetry operation application complete ===`);
            console.log(`Final atom count: ${optimizedData.getCount()}`);
            
            // Return optimized data structure
            return optimizedData;
        }

        // Function to parse atom list from CIF file
        function parseAtomList(lines) {
            console.log('=== Starting atom list parsing ===');
            
            // 1. Detect all loop_ blocks
            const loopBlocks = [];
            let currentBlock = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === 'loop_') {
                    // Start of a new loop_ block
                    if (currentBlock) {
                        loopBlocks.push(currentBlock);
                    }
                    currentBlock = {
                        startLine: i,
                        headers: [],
                        data: []
                    };
                } else if (currentBlock && line) {
                    if (line.trim().startsWith('_')) {
                        // header line (remove indentation and save)
                        currentBlock.headers.push(line.trim());
                    } else if (currentBlock.headers.length > 0) {
                        // data line
                        currentBlock.data.push(line);
                    }
                } else if (currentBlock && !line && currentBlock.headers.length > 0) {
                    // end of block with blank line
                    loopBlocks.push(currentBlock);
                    currentBlock = null;
                }
            }
            
            // add last block
            if (currentBlock) {
                loopBlocks.push(currentBlock);
            }
            
                            console.log(`Number of detected loop_ blocks: ${loopBlocks.length}`);
                
                // 2. Search for block containing atom coordinates
                let atomBlock = null;
                for (let i = 0; i < loopBlocks.length; i++) {
                    const block = loopBlocks[i];
                    const headers = block.headers;
                    
                    console.log(`Block ${i + 1} headers:`, headers);
                    
                    // Check if all required coordinate headers are included
                    const hasX = headers.some(h => h === '_atom_site_fract_x');
                    const hasY = headers.some(h => h === '_atom_site_fract_y');
                    const hasZ = headers.some(h => h === '_atom_site_fract_z');
                    
                    if (hasX && hasY && hasZ) {
                        console.log(`Found atom coordinate block: block ${i + 1}`);
                        atomBlock = block;
                        break;
                    }
                }
                
                if (!atomBlock) {
                    throw new Error('No loop_ block found containing atom coordinate information (_atom_site_fract_x, _atom_site_fract_y, _atom_site_fract_z).');
                }
            
                // 3. determine method to obtain element information
                const headers = atomBlock.headers;
                let symbolColumn = -1;
                let labelColumn = -1;
                let xColumn = -1;
                let yColumn = -1;
                let zColumn = -1;
                let occupancyColumn = -1;
                
                // Identify position of each column
                headers.forEach((header, index) => {
                    if (header === '_atom_site_fract_x') xColumn = index;
                    else if (header === '_atom_site_fract_y') yColumn = index;
                    else if (header === '_atom_site_fract_z') zColumn = index;
                    else if (header === '_atom_site_type_symbol') symbolColumn = index;
                    else if (header === '_atom_site_label') labelColumn = index;
                    else if (header === '_atom_site_occupancy') occupancyColumn = index;
                });
                
                console.log(`Column positions: x=${xColumn}, y=${yColumn}, z=${zColumn}, symbol=${symbolColumn}, label=${labelColumn}, occupancy=${occupancyColumn}`);
                
                // 4. parse atom data
                const atoms = [];
                const dataLines = atomBlock.data;
            
                            for (let i = 0; i < dataLines.length; i++) {
                    const line = dataLines[i];
                    const parts = line.split(/\s+/).filter(part => part.length > 0);
                    
                    if (parts.length < Math.max(xColumn, yColumn, zColumn) + 1) {
                        console.warn(`Data row ${i + 1} has insufficient columns: ${parts.length} < ${Math.max(xColumn, yColumn, zColumn) + 1}`);
                        continue;
                    }
                    
                    // Get coordinates
                    const x = parseFloat(parts[xColumn]);
                    const y = parseFloat(parts[yColumn]);
                    const z = parseFloat(parts[zColumn]);
                    
                    if (isNaN(x) || isNaN(y) || isNaN(z)) {
                        console.warn(`Data row ${i + 1} has invalid coordinates: x=${parts[xColumn]}, y=${parts[yColumn]}, z=${parts[zColumn]}`);
                        continue;
                    }
                    
                    // Get occupancy (default is 1.0)
                    let occupancy = 1.0;
                    if (occupancyColumn >= 0 && occupancyColumn < parts.length) {
                        const occValue = parseFloat(parts[occupancyColumn]);
                        if (!isNaN(occValue)) {
                            occupancy = occValue;
                        }
                    }
                    
                    // Get label
                    let label = `atom_${i + 1}`;
                    if (labelColumn >= 0 && labelColumn < parts.length) {
                        label = parts[labelColumn];
                    }
                    
                    // Determine element
                    let symbol = '?';
                
                                    // Function to extract element symbol
                    function extractElementSymbol(input) {
                        if (!input || input === '?') {
                            return '?';
                        }
                        
                        console.log(`Extracting element symbol: "${input}"`);
                        
                        // Parse character by character from left
                        let result = '';
                        let foundAlphabet = false;
                        let alphabetPart = '';
                        
                        for (let i = 0; i < input.length; i++) {
                            const char = input[i];
                            const isAlphabet = /[A-Za-z]/.test(char);
                            
                            console.log(`  Position ${i}: "${char}" (alphabet: ${isAlphabet})`);
                            
                            if (isAlphabet) {
                                // Alphabet found
                                foundAlphabet = true;
                                alphabetPart += char;
                                console.log(`    Alphabet part: "${alphabetPart}"`);
                            } else {
                                // Non-alphabet character
                                if (foundAlphabet) {
                                    // If alphabet already found, end here
                                    console.log(`    Non-alphabet character after alphabet detected: ending at position ${i}`);
                                    break;
                                } else {
                                    // If alphabet not found yet, add as is
                                    result += char;
                                    console.log(`    Adding character before alphabet: "${result}"`);
                                }
                            }
                        }
                        
                        // Determine result
                        if (foundAlphabet) {
                            // If alphabet found, return only alphabet part
                            result = alphabetPart;
                            console.log(`  Returning only alphabet part: "${result}"`);
                        } else {
                            // If no alphabet found, use entire input
                            result = input;
                            console.log(`  No alphabet found, using entire input: "${result}"`);
                        }
                        
                        console.log(`  Final result: "${result}"`);
                        return result;
                    }
                
                // 5. prioritize _atom_site_type_symbol
                if (symbolColumn >= 0 && symbolColumn < parts.length) {
                    const typeSymbol = parts[symbolColumn];
                    if (typeSymbol && typeSymbol !== '?') {
                        symbol = extractElementSymbol(typeSymbol);
                    } else if (labelColumn >= 0 && labelColumn < parts.length) {
                        // 6. if _atom_site_type_symbol is '?', estimate from _atom_site_label
                        const atomLabel = parts[labelColumn];
                        if (atomLabel && atomLabel !== '?') {
                            symbol = extractElementSymbol(atomLabel);
                        }
                    }
                } else if (labelColumn >= 0 && labelColumn < parts.length) {
                    // if _atom_site_type_symbol is not present, estimate from _atom_site_label
                    const atomLabel = parts[labelColumn];
                    if (atomLabel && atomLabel !== '?') {
                        symbol = extractElementSymbol(atomLabel);
                    }
                }
                
                    // 7. Error if element cannot be defined
                    if (symbol === '?' || !symbol) {
                        throw new Error(`Cannot define element for data row ${i + 1}. label: "${label}", type_symbol: "${symbolColumn >= 0 ? parts[symbolColumn] : 'N/A'}"`);
                    }
                    
                    const atom = {
                        label: label,
                        symbol: symbol,
                        x: x,
                        y: y,
                        z: z,
                        occupancy: occupancy
                    };
                    
                    atoms.push(atom);
                    console.log(`Atom ${i + 1}: ${label} (${symbol}) at (${x}, ${y}, ${z}), occupancy: ${occupancy}`);
                }
                
                console.log(`=== Atom list parsing complete: ${atoms.length} atoms found ===`);
            return atoms;
        }

        async function parseCIF(content) {
            console.log('parseCIF called with content length:', content.length);
            console.log('Content preview:', content.substring(0, 200));
            
            // Clear file parsing log
            clearParseLog();
            addParseLog('Started parsing CIF file...', 'info');
            
            try {
                const lines = content.split('\n');
                console.log('Split into lines:', lines.length);
                
                crystalData = {
                    cellLengths: {},
                    cellAngles: {},
                    atoms: [],
                    spaceGroup: '',
                    spaceGroupNumber: '',
                    symmetryOperations: []
                };

                // Parse lattice constants and space group (execute first)
                let spaceGroupFound = false;
                let spaceGroupNumberFound = false;
                let usedAlternativeSpaceGroupName = false;
                let usedAlternativeSpaceGroupNumber = false;
                let bothSpaceGroupNameKeywordsNotFound = false;
                let bothSpaceGroupNumberKeywordsNotFound = false;
                
                for (let line of lines) {
                    line = line.trim();
                    
                    // Parse lattice constants
                    if (line.trim().startsWith('_cell_length_a')) {
                        crystalData.cellLengths.a = parseFloat(line.trim().split(/\s+/)[1]);
                    } else if (line.trim().startsWith('_cell_length_b')) {
                        crystalData.cellLengths.b = parseFloat(line.trim().split(/\s+/)[1]);
                    } else if (line.trim().startsWith('_cell_length_c')) {
                        crystalData.cellLengths.c = parseFloat(line.trim().split(/\s+/)[1]);
                    } else if (line.trim().startsWith('_cell_angle_alpha')) {
                        crystalData.cellAngles.alpha = parseFloat(line.trim().split(/\s+/)[1]);
                    } else if (line.trim().startsWith('_cell_angle_beta')) {
                        crystalData.cellAngles.beta = parseFloat(line.trim().split(/\s+/)[1]);
                    } else if (line.trim().startsWith('_cell_angle_gamma')) {
                        crystalData.cellAngles.gamma = parseFloat(line.trim().split(/\s+/)[1]);
                    }
                    
                    // Parse space group name (with priority)
                    if (!spaceGroupFound) {
                        if (line.trim().startsWith('_space_group_name_H-M_alt')) {
                            console.log('Raw line for _space_group_name_H-M_alt:', line);
                            const parts = line.trim().split("'");
                            console.log('Split parts:', parts);
                            if (parts.length > 1) {
                                crystalData.spaceGroup = parts[1];
                            } else {
                                // Fallback: try splitting by whitespace
                                const spaceGroupParts = line.trim().split(/\s+/);
                                if (spaceGroupParts.length > 1) {
                                    crystalData.spaceGroup = spaceGroupParts[1];
                                }
                            }
                            spaceGroupFound = true;
                            console.log('Space group name detected: _space_group_name_H-M_alt =', crystalData.spaceGroup);
                            addParseLog(`Space group name detected: _space_group_name_H-M_alt = ${crystalData.spaceGroup}`, 'success');
                        } else if (line.trim().startsWith('_symmetry_space_group_name_H-M')) {
                            console.log('Raw line for _symmetry_space_group_name_H-M:', line);
                            const parts = line.trim().split("'");
                            console.log('Split parts:', parts);
                            if (parts.length > 1) {
                                crystalData.spaceGroup = parts[1];
                            } else {
                                // Fallback: try splitting by whitespace
                                const spaceGroupParts = line.trim().split(/\s+/);
                                if (spaceGroupParts.length > 1) {
                                    crystalData.spaceGroup = spaceGroupParts[1];
                                }
                            }
                            spaceGroupFound = true;
                            usedAlternativeSpaceGroupName = true;
                            console.log('Space group name detected: _symmetry_space_group_name_H-M (alternative keyword) =', crystalData.spaceGroup);
                            addParseLog(`Space group name detected: _symmetry_space_group_name_H-M (alternative keyword) = ${crystalData.spaceGroup}`, 'success');
                        }
                    }
                    
                    // Parse space group number (with priority)
                    if (!spaceGroupNumberFound) {
                        if (line.trim().startsWith('_space_group_IT_number')) {
                            crystalData.spaceGroupNumber = line.trim().split(/\s+/)[1];
                            spaceGroupNumberFound = true;
                            console.log('Space group number detected: _space_group_IT_number =', crystalData.spaceGroupNumber);
                            addParseLog(`Space group number detected: _space_group_IT_number = ${crystalData.spaceGroupNumber}`, 'success');
                        } else if (line.trim().startsWith('_symmetry_Int_Tables_number')) {
                            crystalData.spaceGroupNumber = line.trim().split(/\s+/)[1];
                            spaceGroupNumberFound = true;
                            usedAlternativeSpaceGroupNumber = true;
                            console.log('Space group number detected: _symmetry_Int_Tables_number =', crystalData.spaceGroupNumber);
                            addParseLog(`Space group number detected: _symmetry_Int_Tables_number = ${crystalData.spaceGroupNumber}`, 'success');
                        }
                    }
                }
                
                // Check if both keywords were not found
                if (!spaceGroupFound) {
                    bothSpaceGroupNameKeywordsNotFound = true;
                }
                if (!spaceGroupNumberFound) {
                    bothSpaceGroupNumberKeywordsNotFound = true;
                }

                // Processing when space group number is detected (embedded data available)
                if (crystalData.spaceGroupNumber) {
                    const spaceGroupNumber = parseInt(crystalData.spaceGroupNumber);
                    console.log(`Space group number ${spaceGroupNumber} detected.`);
                    addParseLog(`Space group number ${spaceGroupNumber} detected.`, 'info');
                    
                    // Check if embedded data exists (for fallback)
                    if (typeof embeddedSpaceGroupData !== 'undefined' && embeddedSpaceGroupData[spaceGroupNumber]) {
                        console.log(`Embedded data for space group ${spaceGroupNumber} is available (for fallback)`);
                        addParseLog(`Embedded data for space group ${spaceGroupNumber} is available (for fallback)`, 'info');
                    } else {
                        console.log(`No data for space group ${spaceGroupNumber} in embedded data.`);
                        addParseLog(`Data for space group ${spaceGroupNumber} is not included in embedded data.`, 'warning');
                    }
                }

                // Parse symmetry operations (execute after getting space group information)
                crystalData.symmetryOperations = await parseSymmetryOperations(lines);
                
                // Display warnings for alternative keywords usage
                if (bothSpaceGroupNameKeywordsNotFound) {
                    addParseLog('Note: Neither _space_group_name_H-M_alt nor _symmetry_space_group_name_H-M found in CIF file. The recommended keyword is _space_group_name_H-M_alt.', 'warning');
                } else if (usedAlternativeSpaceGroupName) {
                    addParseLog('Note: _space_group_name_H-M_alt not found, using _symmetry_space_group_name_H-M instead. The recommended keyword is _space_group_name_H-M_alt.', 'warning');
                }
                
                if (bothSpaceGroupNumberKeywordsNotFound) {
                    addParseLog('Note: Neither _space_group_IT_number nor _symmetry_Int_Tables_number found in CIF file. The recommended keyword is _space_group_IT_number.', 'warning');
                } else if (usedAlternativeSpaceGroupNumber) {
                    addParseLog('Note: _space_group_IT_number not found, using _symmetry_Int_Tables_number instead. The recommended keyword is _space_group_IT_number.', 'warning');
                }

                // Parse atom list
                crystalData.atoms = parseAtomList(lines);

                // Debug logs
                console.log('Parsed atom data:', crystalData.atoms);
                console.log('Symmetry operations:', crystalData.symmetryOperations);
                console.log('Space group number:', crystalData.spaceGroupNumber);
                console.log('Space group name:', crystalData.spaceGroup);
                
                // Apply symmetry operations to generate atom list (optimized)
                const originalAtomCount = crystalData.atoms.length;
                crystalData.optimizedAtomData = generateSymmetryEquivalentAtoms(crystalData.atoms, crystalData.symmetryOperations);
                const totalAtomCount = crystalData.optimizedAtomData.getCount();

                // Get unique symbols from optimized data structure
                const uniqueSymbols = Array.from(crystalData.optimizedAtomData.atomsBySymbol.keys());
                atoms = uniqueSymbols;
                
                console.log('Generated elements:', uniqueSymbols);
                console.log('atoms variable:', atoms);
                
                updateAtomSelects(uniqueSymbols);
                displayCrystalInfo();
                document.getElementById('searchBtn').disabled = false;
                
                addParseLog(`CIF file parsing completed. Generated atom list by applying symmetry operations.
Original atom count: ${originalAtomCount} atom(s) ‚Üí After symmetry operations: ${totalAtomCount}
atom(s)`, 'success');
                
            } catch (error) {
                showError('An error occurred while parsing the CIF file: ' + error.message);
            }
        }



        function updateAtomSelects(symbols) {
            console.log('updateAtomSelects called with symbols:', symbols);
            
            const atom1Select = document.getElementById('atom1');
            const atom2Select = document.getElementById('atom2');
            
            console.log('Found select elements:', atom1Select, atom2Select);
            
            // Clear existing options
            atom1Select.innerHTML = '<option value="">Please select</option>';
            atom2Select.innerHTML = '<option value="">Please select</option>';
            
            // Add new options
            symbols.forEach(symbol => {
                atom1Select.innerHTML += `<option value="${symbol}">${symbol}</option>`;
                atom2Select.innerHTML += `<option value="${symbol}">${symbol}</option>`;
            });
            
            // Add "All atoms" option to Atom 2 only
            atom2Select.innerHTML += `<option value="ALL">All atoms</option>`;
            
            console.log('Updated select elements:', atom1Select.innerHTML, atom2Select.innerHTML);
        }

        function displayCrystalInfo() {
            if (!crystalData) return;
            
            const details = document.getElementById('crystalDetails');
            details.innerHTML = `
                <p><strong>Lattice Constants:</strong> a = ${crystalData.cellLengths.a?.toFixed(3) || 'N/A'} √Ö, 
                b = ${crystalData.cellLengths.b?.toFixed(3) || 'N/A'} √Ö, 
                c = ${crystalData.cellLengths.c?.toFixed(3) || 'N/A'} √Ö</p>
                <p><strong>Lattice Angles:</strong> Œ± = ${crystalData.cellAngles.alpha?.toFixed(1) || 'N/A'}¬∞, 
                Œ≤ = ${crystalData.cellAngles.beta?.toFixed(1) || 'N/A'}¬∞, 
                Œ≥ = ${crystalData.cellAngles.gamma?.toFixed(1) || 'N/A'}¬∞</p>
                <p><strong>Space Group:</strong> ${crystalData.spaceGroup || 'N/A'} ${crystalData.spaceGroupNumber ? `(No. ${crystalData.spaceGroupNumber})` : ''}</p>
                <p><strong>Number of Atoms:</strong> ${crystalData.optimizedAtomData ? crystalData.optimizedAtomData.getCount() : 'N/A'}</p>
                <p><strong>Elements:</strong> ${atoms.join(', ')}</p>
            `;
            
            // Add detailed display of atom list
            displayAtomList();
            
            document.getElementById('crystalInfo').style.display = 'block';
        }

        function displayAtomList() {
            if (!crystalData || !crystalData.optimizedAtomData) return;
            
            // Create or get element for atom list display
            let atomListContainer = document.getElementById('atomListContainer');
            if (!atomListContainer) {
                atomListContainer = document.createElement('div');
                atomListContainer.id = 'atomListContainer';
                atomListContainer.className = 'atom-list-container';
                document.getElementById('crystalInfo').appendChild(atomListContainer);
            }
            
            // Use optimized data structure
            const optimizedData = crystalData.optimizedAtomData;
            let atomListHTML = '<h4>Details of Discovered Atoms (scroll to view)</h4>';
            
            // Iterate through symbols using optimized structure
            for (const [symbol, atomIndices] of optimizedData.atomsBySymbol) {
                const symbolAtoms = atomIndices.map(index => optimizedData.atoms[index]);
                
                atomListHTML += `
                    <div class="atom-symbol-group">
                        <h5>${symbol} atoms (${symbolAtoms.length})</h5>
                        <div class="atom-table-container">
                            <table class="atom-table">
                                <thead>
                                    <tr>
                                        <th>Label</th>
                                        <th>Occupancy</th>
                                        <th>X Coordinate</th>
                                        <th>Y Coordinate</th>
                                        <th>Z Coordinate</th>
                                        <th>Type</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                symbolAtoms.forEach(atom => {
                    const type = atom.original ? 'Original' : 'Generated by Symmetry';
                    atomListHTML += `
                        <tr>
                            <td>${atom.label}</td>
                            <td>${atom.occupancy.toFixed(4)}</td>
                            <td>${atom.x.toFixed(6)}</td>
                            <td>${atom.y.toFixed(6)}</td>
                            <td>${atom.z.toFixed(6)}</td>
                            <td>${type}</td>
                        </tr>
                    `;
                });
                
                atomListHTML += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }
            
            atomListContainer.innerHTML = atomListHTML;
        }

        function searchBonds() {
            const atom1 = document.getElementById('atom1').value;
            const atom2 = document.getElementById('atom2').value;
            const minDistance = parseFloat(document.getElementById('minDistance').value);
            const maxDistance = parseFloat(document.getElementById('maxDistance').value);
            // search range is automatically determined, so use fixed value
            const searchRange = 0; // not used, but kept for compatibility

            if (!atom1 || !atom2) {
                showError('Please select both elements.');
                return;
            }

            if (minDistance >= maxDistance) {
                showError('Minimum distance must be less than maximum distance.');
                return;
            }

            // if already searching, stop
            if (isSearching) {
                stopSearch();
                return;
            }

            // start search
            isSearching = true;
            updateSearchButtons();
            showLoading();
            
            // Update search status title to searching
            updateSearchStatusTitle('searching');
            
            // execute directly (without using Web Worker)
            setTimeout(() => {
                if (!isSearching) { // Check if search was stopped before starting
                    console.log('Search was stopped before starting execution');
                    return;
                }
                
                if (isSearching) { // execute only if not stopped
                    try {

                        
                        // define function for progress message
                        function postProgressMessage(message) {
                            updateProgressMessage(message);
                        }
                        
                        function getBondTypeOptimized(distance, symbol1, symbol2) {
                            
                            // improved fallback processing
                            function getEstimatedRadius(symbol) {
                                if (covalentRadii[symbol]) {
                                    return covalentRadii[symbol];
                                }
                                
                                // estimate atomic number from element symbol
                                const elementSymbols = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn'];
                                const atomicNumber = elementSymbols.indexOf(symbol) + 1;
                                
                                if (atomicNumber > 0) {
                                    // estimated radius based on atomic number (simplified version)
                                    if (atomicNumber <= 10) {
                                        return 0.5 + (atomicNumber * 0.1); // 1st period: 0.6-1.5 √Ö
                                    } else if (atomicNumber <= 18) {
                                        return 1.0 + ((atomicNumber - 10) * 0.08); // 2nd period: 1.08-1.64 √Ö
                                    } else if (atomicNumber <= 36) {
                                        return 1.5 + ((atomicNumber - 18) * 0.03); // 3rd-4th period: 1.53-2.04 √Ö
                                    } else {
                                        return 2.0 + ((atomicNumber - 36) * 0.02); // 5th period and beyond: 2.02+ √Ö
                                    }
                                }
                                
                                // final fallback
                                return 1.5;
                            }
                            
                            const r1 = getEstimatedRadius(symbol1);
                            const r2 = getEstimatedRadius(symbol2);
                            const sumRadii = r1 + r2;
                            
                            // warning if default value is used
                            if (!covalentRadii[symbol1] || !covalentRadii[symbol2]) {
                                const unknownElements = [];
                                if (!covalentRadii[symbol1]) unknownElements.push(symbol1);
                                if (!covalentRadii[symbol2]) unknownElements.push(symbol2);
                                
                                console.warn(`Warning: Covalent radius data for elements ${unknownElements.join(', ')} does not exist. Using estimated values.`);
                                
                                // display warning only once
                                if (!window.bondWarningShown) {
                                    showInfo(`‚ö†Ô∏è Warning: Covalent radius data for elements ${unknownElements.join(', ')} does not exist. Using estimated values. The reliability of the results may be reduced.`);
                                    window.bondWarningShown = true;
                                }
                            }
                            
                            if (distance <= sumRadii * 1.2) {
                                return 'Strong_Bond';
                            } else if (distance <= sumRadii * 1.5) {
                                return 'Weak_Bond';
                            } else {
                                return 'Non_Bond';
                            }
                        }
                        
                        function calculateOptimalSearchRanges(atoms1, maxDist, a, b, c) {
                            let n2_min = Infinity, n2_max = -Infinity;
                            let m2_min = Infinity, m2_max = -Infinity;
                            let l2_min = Infinity, l2_max = -Infinity;
                            
                            atoms1.forEach(atom1 => {
                                const i1 = atom1.x;
                                const j1 = atom1.y;
                                const k1 = atom1.z;
                                
                                const n2_x = Math.floor((maxDist + i1 * a) / a);
                                const n2_y = Math.ceil((-maxDist + i1 * a) / a);
                                const m2_x = Math.floor((maxDist + j1 * b) / b);
                                const m2_y = Math.ceil((-maxDist + j1 * b) / b);
                                const l2_x = Math.floor((maxDist + k1 * c) / c);
                                const l2_y = Math.ceil((-maxDist + k1 * c) / c);
                                
                                n2_min = Math.min(n2_min, n2_y);
                                n2_max = Math.max(n2_max, n2_x);
                                m2_min = Math.min(m2_min, m2_y);
                                m2_max = Math.max(m2_max, m2_x);
                                l2_min = Math.min(l2_min, l2_y);
                                l2_max = Math.max(l2_max, l2_x);
                            });
                            
                            return { n2_min, n2_max, m2_min, m2_max, l2_min, l2_max };
                        }
                        
                        function findAtomsInRange(centerAtom, targetSymbol, searchRanges, crystalData, a, b, c, minDistSq, maxDistSq) {
                            const nearbyAtoms = [];
                            const atoms2 = crystalData.atoms.filter(atom => atom.symbol === targetSymbol);
                            
                            for (let n2 = searchRanges.n2_min; n2 <= searchRanges.n2_max; n2++) {
                                for (let m2 = searchRanges.m2_min; m2 <= searchRanges.m2_max; m2++) {
                                    for (let l2 = searchRanges.l2_min; l2 <= searchRanges.l2_max; l2++) {
                                        atoms2.forEach(atom2 => {
                                            const x2 = n2 + atom2.x;
                                            const y2 = m2 + atom2.y;
                                            const z2 = l2 + atom2.z;
                                            
                                            const dx = (x2 - centerAtom.x) * a;
                                            const dy = (y2 - centerAtom.y) * b;
                                            const dz = (z2 - centerAtom.z) * c;
                                            const distSq = dx*dx + dy*dy + dz*dz;
                                            
                                            if (distSq >= minDistSq && distSq <= maxDistSq) {
                                                nearbyAtoms.push({
                                                    x: x2, y: y2, z: z2,
                                                    symbol: atom2.symbol,
                                                    originalLabel: atom2.label,
                                                    i: n2, j: m2, k: l2
                                                });
                                            }
                                        });
                                    }
                                }
                            }
                            
                            return nearbyAtoms;
                        }
                        
                        function findBondsOptimized(atom1Symbol, atom2Symbol, minDist, maxDist, range, crystalData) {
                            return new Promise((resolve, reject) => {
                                console.log(`\n=== findBondsOptimized started ===`);
                                console.log(`Searching for bonds between ${atom1Symbol} and ${atom2Symbol}`);
                                console.log(`Distance range: ${minDist} to ${maxDist} √Ö`);
                                
                                const bonds = [];
                                const a = crystalData.cellLengths.a;
                                const b = crystalData.cellLengths.b;
                                const c = crystalData.cellLengths.c;
                                const alpha = crystalData.cellAngles.alpha;
                                const beta = crystalData.cellAngles.beta;
                                const gamma = crystalData.cellAngles.gamma;
                                
                                // Debug: log cell parameters
                                console.log('Cell parameters:', { a, b, c, alpha, beta, gamma });
                                const minDistSq = minDist * minDist;
                                const maxDistSq = maxDist * maxDist;
                                
                                console.log('Distance squared range:', { minDistSq, maxDistSq });
                                
                                // Use optimized data structure for faster atom retrieval
                                const optimizedData = crystalData.optimizedAtomData;
                                const atoms1 = optimizedData.getAtomsBySymbol(atom1Symbol);
                                console.log(`Found ${atoms1.length} ${atom1Symbol} atoms:`, atoms1.map(a => `${a.label}(${a.x.toFixed(4)}, ${a.y.toFixed(4)}, ${a.z.toFixed(4)})`));
                                postProgressMessage(`Step 1: Listed ${atoms1.length} ${atom1Symbol} atoms`);
                            
                                console.log(`\n--- Calculating search ranges ---`);
                                if (atom2Symbol === 'ALL') {
                                    console.log(`Looking for ALL atoms around ${atom1Symbol} atoms`);
                                } else {
                                    console.log(`Looking for ${atom2Symbol} atoms around ${atom1Symbol} atoms`);
                                }
                                const searchRanges = calculateOptimalSearchRanges(atoms1, maxDist, a, b, c, alpha, beta, gamma);
                                console.log(`Search ranges calculated:`, searchRanges);
                                postProgressMessage(`Step 2 complete: Determined search range (n2: ${searchRanges.n2_min} to ${searchRanges.n2_max}, m2: ${searchRanges.m2_min} to ${searchRanges.m2_max}, l2: ${searchRanges.l2_min} to ${searchRanges.l2_max})`);
                                
                                                // Process atoms in chunks to allow UI updates
                const processAtomsInChunks = (startIndex) => {
                    // Check if search was stopped
                    if (!isSearching) {
                        console.log('Search was stopped, terminating processing');
                        postProgressMessage('‚ùå Search stopped by user');
                        reject(new Error('Search stopped by user'));
                        return;
                    }
                    
                    const chunkSize = 10; // Process 10 atoms at a time
                    const endIndex = Math.min(startIndex + chunkSize, atoms1.length);
                    
                    for (let i = startIndex; i < endIndex; i++) {
                        // Check if search was stopped during processing
                        if (!isSearching) {
                            console.log('Search was stopped during atom processing');
                            postProgressMessage('‚ùå Search stopped by user');
                            reject(new Error('Search stopped by user'));
                            return;
                        }
                                        const atom1 = atoms1[i];
                                        const processedAtoms = i + 1;
                                        
                                        console.log(`\n=== Processing atom ${processedAtoms}/${atoms1.length}: ${atom1.label} ===`);
                                        console.log(`Atom coordinates: (${atom1.x.toFixed(4)}, ${atom1.y.toFixed(4)}, ${atom1.z.toFixed(4)})`);
                                        
                                        if (atom2Symbol === 'ALL') {
                                            console.log(`Processing ${atom1.label} - searching for ALL atoms...`);
                                        } else {
                                            console.log(`Processing ${atom1.label} - searching for ${atom2Symbol} atoms...`);
                                        }
                                        
                                        // Search for atoms in neighboring cells using calculated search ranges
                                        const nearbyAtoms2 = [];
                                        
                                        // Handle "All atoms" selection for atom2 (optimized)
                                        let atoms2;
                                        if (atom2Symbol === 'ALL') {
                                            atoms2 = optimizedData.getAllAtoms();
                                            console.log(`Searching for ALL atoms around ${atom1.label}`);
                                        } else {
                                            atoms2 = optimizedData.getAtomsBySymbol(atom2Symbol);
                                            console.log(`Found ${atoms2.length} ${atom2Symbol} atoms in crystal data`);
                                        }
                                        
                                        if (atoms2.length > 0) {
                                            console.log('First few atoms:', atoms2.slice(0, 3).map(a => `${a.label}(${a.x.toFixed(4)}, ${a.y.toFixed(4)}, ${a.z.toFixed(4)})`));
                                            
                                                                        // Search in neighboring cells using the calculated search ranges
                            for (let n2 = searchRanges.n2_min; n2 <= searchRanges.n2_max; n2++) {
                                // Check if search was stopped during cell iteration
                                if (!isSearching) {
                                    console.log('Search was stopped during cell iteration');
                                    postProgressMessage('‚ùå Search stopped by user');
                                    reject(new Error('Search stopped by user'));
                                    return;
                                }
                                
                                for (let m2 = searchRanges.m2_min; m2 <= searchRanges.m2_max; m2++) {
                                    for (let l2 = searchRanges.l2_min; l2 <= searchRanges.l2_max; l2++) {
                                                        atoms2.forEach(atom2 => {
                                                            // Calculate coordinates in the neighboring cell
                                                            const x2 = n2 + atom2.x;
                                                            const y2 = m2 + atom2.y;
                                                            const z2 = l2 + atom2.z;
                                                            
                                                            // Create a temporary atom object with the cell-shifted coordinates
                                                            const shiftedAtom2 = {
                                                                x: x2,
                                                                y: y2,
                                                                z: z2,
                                                                label: atom2.label,
                                                                symbol: atom2.symbol
                                                            };
                                                            
                                                            const distance = calculateDistanceOptimized(atom1, shiftedAtom2, a, b, c, alpha, beta, gamma);
                                                            
                                                            if (distance >= Math.sqrt(minDistSq) && distance <= Math.sqrt(maxDistSq)) {
                                                                console.log(`BOND FOUND: ${atom1.label} - ${atom2.label} (${distance.toFixed(4)} √Ö) in cell (${n2}, ${m2}, ${l2})`);
                                                                nearbyAtoms2.push({
                                                                    x: atom2.x, // Original fractional coordinates
                                                                    y: atom2.y,
                                                                    z: atom2.z,
                                                                    symbol: atom2.symbol,
                                                                    originalLabel: atom2.label,
                                                                    i: n2, j: m2, k: l2 // Cell coordinates
                                                                });
                                                            }
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                        
                                        console.log(`Found ${nearbyAtoms2.length} nearby atoms for ${atom1.label}`);
                                        
                                        nearbyAtoms2.forEach(nearbyAtom => {
                                            // Calculate distance using the optimized function
                                            const distance = calculateDistanceOptimized(atom1, nearbyAtom, a, b, c, alpha, beta, gamma);
                                            const distSq = distance * distance;
                                            
                                            if (distSq >= minDistSq && distSq <= maxDistSq) {
                                                if (!(nearbyAtom.i === 0 && nearbyAtom.j === 0 && nearbyAtom.k === 0) || 
                                                    atom1.label !== nearbyAtom.originalLabel) {
                                                    
                                                    // Calculate bonding vector: atom2_coords + cell_coords - atom1_coords
                                                    const dx = (nearbyAtom.x + nearbyAtom.i) - atom1.x;
                                                    const dy = (nearbyAtom.y + nearbyAtom.j) - atom1.y;
                                                    const dz = (nearbyAtom.z + nearbyAtom.k) - atom1.z;

                                                    bonds.push({
                                                        atom1: atom1.label,
                                                        atom2: nearbyAtom.originalLabel,
                                                        atom1Coords: `(${atom1.x.toFixed(4)}, ${atom1.y.toFixed(4)}, ${atom1.z.toFixed(4)})`,
                                                        atom2Coords: `(${nearbyAtom.x.toFixed(4)}, ${nearbyAtom.y.toFixed(4)}, ${nearbyAtom.z.toFixed(4)})`,
                                                        distance: distance,
                                                        relativePosition: `(${nearbyAtom.i}, ${nearbyAtom.j}, ${nearbyAtom.k})`,
                                                        bondVector: `(${dx.toFixed(4)}, ${dy.toFixed(4)}, ${dz.toFixed(4)})`,
                                                        bondType: getBondTypeOptimized(distance, atom1.symbol, nearbyAtom.symbol)
                                                    });
                                                }
                                            }
                                        });
                                    }
                                    
                                    // Update progress message (simplified, less frequent)
                                    if (endIndex % 20 === 0 || endIndex === atoms1.length) {
                                        const progressPercent = Math.round((endIndex / atoms1.length) * 100);
                                        if (atom2Symbol === 'ALL') {
                                            postProgressMessage(`Processing ${endIndex}/${atoms1.length} atoms (${progressPercent}%) - ${bonds.length} bonds found`);
                                        } else {
                                            postProgressMessage(`Processing ${endIndex}/${atoms1.length} atoms (${progressPercent}%) - ${bonds.length} bonds found`);
                                        }
                                    }
                                    
                                    // Continue processing or finish
                                    if (endIndex < atoms1.length) {
                                        // Process next chunk after a short delay to allow UI updates
                                        setTimeout(() => {
                                            processAtomsInChunks(endIndex);
                                        }, 10);
                                    } else {
                                                                                 // All atoms processed
                                         postProgressMessage(`Step 3-5: Processing complete`);
                                         
                                         // Step 6: Sort by distance
                                         bonds.sort((a, b) => a.distance - b.distance);
                                         postProgressMessage(`Step 6: Sorted ${bonds.length} bonds`);
                                         
                                         // Memory cleanup after processing
                                         cleanupMemory();
                                         
                                         // Display result transmission message
                                         postProgressMessage(`Transmitting results...`);
                                         
                                         // Display transmission complete message
                                         setTimeout(() => {
                                             postProgressMessage(`Complete: ${bonds.length} bonds found`);
                                             resolve(bonds);
                                         }, 100);
                                    }
                                };
                                
                                // Start processing atoms
                                processAtomsInChunks(0);
                            });
                        }
                        
                        try {
                            findBondsOptimized(atom1, atom2, minDistance, maxDistance, searchRange, crystalData)
                                .then(bonds => {
                                    if (!isSearching) { // Check if search was stopped before displaying results
                                        console.log('Search was stopped, not displaying results');
                                        return;
                                    }
                                    
                                    if (bonds && Array.isArray(bonds)) {
                                        // Apply bond equivalence analysis
                                        const processedBonds = assignBondIdentifiers(bonds);
                                        currentBonds = processedBonds; // save results with identifiers
                                        console.log('Search complete: start displaying results', processedBonds.length);
                                        
                                        // display directly (remove asynchronous)
                                        displayResults(processedBonds);
                                        console.log('Display complete');
                                    } else {
                                        showError('Search results are invalid.');
                                    }
                                })
                                .catch(error => {
                                    console.error('Search error:', error);
                                    
                                    // Handle user-initiated stop differently from actual errors
                                    if (error.message === 'Search stopped by user') {
                                        console.log('Search was stopped by user, handled gracefully');
                                        return; // Don't show error message for user-initiated stops
                                    }
                                    
                                    showError('An error occurred during search: ' + error.message);
                                    // Stop spinner on error
                                    const resultsDiv = document.getElementById('results');
                                    const spinner = resultsDiv.querySelector('.spinner');
                                    if (spinner) {
                                        spinner.remove();
                                    }
                                    // Update search status title to error
                                    updateSearchStatusTitle('error');
                                })
                                .finally(() => {
                                    // Always reset search state when processing is complete
                                    isSearching = false;
                                    updateSearchButtons();
                                    console.log('Search processing completed, state reset');
                                });
                        } catch (error) {
                            console.error('Direct execution error:', error);
                            showError('An error occurred during search: ' + error.message);
                            // Stop spinner on error
                            const resultsDiv = document.getElementById('results');
                            const spinner = resultsDiv.querySelector('.spinner');
                            if (spinner) {
                                spinner.remove();
                            }
                            // Update search status title to error
                            updateSearchStatusTitle('error');
                            // Reset search state on error
                            isSearching = false;
                            updateSearchButtons();
                        }
                    } catch (error) {
                        console.error('Direct execution error:', error);
                        showError('An error occurred during search: ' + error.message);
                        // Stop spinner on error
                        const resultsDiv = document.getElementById('results');
                        const spinner = resultsDiv.querySelector('.spinner');
                        if (spinner) {
                            spinner.remove();
                        }
                        // Update search status title to error
                        updateSearchStatusTitle('error');
                        // Reset search state on error
                        isSearching = false;
                        updateSearchButtons();
                    }
                }
            }, 100);
        }



        function postProgressMessage(message) {
            console.log('=== postProgressMessage function started ===');
            console.log('postProgressMessage function called:', message);
            try {
                // send message from Web Worker
                if (typeof self !== 'undefined' && self.postMessage) {
                    try {
                        self.postMessage({ type: 'progress', message: message });
                    } catch (error) {
                        console.error('Web Worker: progress message sending error:', error);
                    }
                } else {
                    console.log('Direct execution: display progress message:', message);
                    try {
                        // Use setTimeout to ensure UI updates are processed
                        setTimeout(() => {
                            updateProgressMessage(message);
                        }, 0);
                        console.log('updateProgressMessage call scheduled');
                    } catch (error) {
                        console.error('updateProgressMessage call error:', error);
                        console.log('An error occurred, but processing will continue');
                    }
                }
                console.log('postProgressMessage function ended');
            } catch (error) {
                console.error('postProgressMessage function overall error:', error);
                console.log('An error occurred, but processing will continue');
            }
            console.log('=== postProgressMessage function ended ===');
        }

        function calculateOptimalSearchRanges(atoms1, maxDist, a, b, c, alpha = 90, beta = 90, gamma = 90) {
            // set initial values (to find min/max for all atoms)
            let n2_min = Infinity, n2_max = -Infinity;
            let m2_min = Infinity, m2_max = -Infinity;
            let l2_min = Infinity, l2_max = -Infinity;
            
            // For safety, use a more conservative search range that accounts for non-orthogonal lattices
            // Add a safety factor to ensure we don't miss any bonds
            const safetyFactor = 2.0; // Increased safety factor
            const adjustedMaxDist = maxDist * safetyFactor;
            
            console.log('Search range calculation:', {
                maxDist,
                adjustedMaxDist,
                a, b, c,
                atomCount: atoms1.length
            });
            
            atoms1.forEach((atom1, index) => {
                const i1 = atom1.x; // internal coordinates of atom1
                const j1 = atom1.y;
                const k1 = atom1.z;
                
                // Use original cell dimensions for search range calculation
                // This ensures we don't miss any bonds due to overly restrictive search ranges
                const n2_x = Math.floor((adjustedMaxDist + i1 * a) / a);
                const n2_y = Math.ceil((-adjustedMaxDist + i1 * a) / a);
                
                const m2_x = Math.floor((adjustedMaxDist + j1 * b) / b);
                const m2_y = Math.ceil((-adjustedMaxDist + j1 * b) / b);
                
                const l2_x = Math.floor((adjustedMaxDist + k1 * c) / c);
                const l2_y = Math.ceil((-adjustedMaxDist + k1 * c) / c);
                
                console.log(`Atom ${index + 1} (${atom1.label}):`, {
                    coords: `(${i1.toFixed(4)}, ${j1.toFixed(4)}, ${k1.toFixed(4)})`,
                    n2_range: `${n2_y} to ${n2_x}`,
                    m2_range: `${m2_y} to ${m2_x}`,
                    l2_range: `${l2_y} to ${l2_x}`
                });
                
                // update min/max for all atoms
                n2_min = Math.min(n2_min, n2_y);
                n2_max = Math.max(n2_max, n2_x);
                m2_min = Math.min(m2_min, m2_y);
                m2_max = Math.max(m2_max, m2_x);
                l2_min = Math.min(l2_min, l2_y);
                l2_max = Math.max(l2_max, l2_x);
            });
            
            const result = {
                n2_min: n2_min,
                n2_max: n2_max,
                m2_min: m2_min,
                m2_max: m2_max,
                l2_min: l2_min,
                l2_max: l2_max
            };
            
            console.log('Final search ranges:', result);
            return result;
        }

        function findAtomsInRange(centerAtom, targetSymbol, searchRanges, crystalData, a, b, c, alpha, beta, gamma, minDistSq, maxDistSq) {
            console.log('=== findAtomsInRange FUNCTION CALLED ===');
            console.log(`Parameters: ${targetSymbol} around ${centerAtom.label}`);
            console.log('Search ranges:', searchRanges);
            
            // For now, just return empty array
            return [];
        }

        // Calculate metric tensor components for non-orthogonal lattices
        function calculateMetricTensor(a, b, c, alpha, beta, gamma) {
            // Ensure angles are valid, default to 90 degrees if undefined
            const safeAlpha = (alpha && !isNaN(alpha)) ? alpha : 90;
            const safeBeta = (beta && !isNaN(beta)) ? beta : 90;
            const safeGamma = (gamma && !isNaN(gamma)) ? gamma : 90;
            
            // Convert angles from degrees to radians
            const alphaRad = safeAlpha * Math.PI / 180;
            const betaRad = safeBeta * Math.PI / 180;
            const gammaRad = safeGamma * Math.PI / 180;
            
            // Calculate cosines
            const cosAlpha = Math.cos(alphaRad);
            const cosBeta = Math.cos(betaRad);
            const cosGamma = Math.cos(gammaRad);
            
            // Metric tensor components (G matrix)
            const g11 = a * a;
            const g22 = b * b;
            const g33 = c * c;
            const g12 = a * b * cosGamma;
            const g13 = a * c * cosBeta;
            const g23 = b * c * cosAlpha;
            
            // For debugging: log metric tensor for orthogonal case
            if (Math.abs(cosAlpha) < 1e-10 && Math.abs(cosBeta) < 1e-10 && Math.abs(cosGamma) < 1e-10) {
                console.log('Orthogonal lattice detected, metric tensor simplified');
            }
            
            return { g11, g22, g33, g12, g13, g23 };
        }

        function calculateDistanceOptimized(atom1, atom2, a, b, c, alpha, beta, gamma) {
            // Calculate distance considering lattice angles (metric tensor approach)
            const dx = atom2.x - atom1.x;
            const dy = atom2.y - atom1.y;
            const dz = atom2.z - atom1.z;
            
            // Get metric tensor components
            const metric = calculateMetricTensor(a, b, c, alpha, beta, gamma);
            
            // Calculate distance using metric tensor: d¬≤ = dx¬≤g11 + dy¬≤g22 + dz¬≤g33 + 2dxdyg12 + 2dxdzg13 + 2dydzg23
            const distanceSquared = dx * dx * metric.g11 + 
                                   dy * dy * metric.g22 + 
                                   dz * dz * metric.g33 + 
                                   2 * dx * dy * metric.g12 + 
                                   2 * dx * dz * metric.g13 + 
                                   2 * dy * dz * metric.g23;
            
            const distance = Math.sqrt(distanceSquared);
            
            // Debug: log distance calculation for first few bonds
            if (Math.random() < 0.01) { // Log only 1% of calculations to avoid spam
                console.log('Distance calculation:', {
                    atom1: atom1.label,
                    atom2: atom2.label,
                    dx, dy, dz,
                    metric,
                    distanceSquared,
                    distance
                });
            }
            
            return distance;
        }



        function getBondTypeOptimized(distance, symbol1, symbol2) {
            
            // improved fallback processing
            function getEstimatedRadius(symbol) {
                if (covalentRadii[symbol]) {
                    return covalentRadii[symbol];
                }
                
                // estimate atomic number from element symbol
                const elementSymbols = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn'];
                const atomicNumber = elementSymbols.indexOf(symbol) + 1;
                
                if (atomicNumber > 0) {
                    // estimated radius based on atomic number (simplified version)
                    if (atomicNumber <= 10) {
                        return 0.5 + (atomicNumber * 0.1); // 1st period: 0.6-1.5 √Ö
                    } else if (atomicNumber <= 18) {
                        return 1.0 + ((atomicNumber - 10) * 0.08); // 2nd period: 1.08-1.64 √Ö
                    } else if (atomicNumber <= 36) {
                        return 1.5 + ((atomicNumber - 18) * 0.03); // 3rd-4th period: 1.53-2.04 √Ö
                    } else {
                        return 2.0 + ((atomicNumber - 36) * 0.02); // 5th period and beyond: 2.02+ √Ö
                    }
                }
                
                // final fallback
                return 1.5;
            }
            
            const r1 = getEstimatedRadius(symbol1);
            const r2 = getEstimatedRadius(symbol2);
            const sumRadii = r1 + r2;
            
            // warning if default value is used
            if (!covalentRadii[symbol1] || !covalentRadii[symbol2]) {
                const unknownElements = [];
                if (!covalentRadii[symbol1]) unknownElements.push(symbol1);
                if (!covalentRadii[symbol2]) unknownElements.push(symbol2);
                
                console.warn(`Warning: Covalent radius data for elements ${unknownElements.join(', ')} does not exist. Using estimated values.`);
                
                // display warning only once
                if (!window.bondWarningShown) {
                    showInfo(`‚ö†Ô∏è Warning: Covalent radius data for elements ${unknownElements.join(', ')} does not exist. Using estimated values. The reliability of the results may be reduced.`);
                    window.bondWarningShown = true;
                }
            }
            
            if (distance <= sumRadii * 1.2) {
                return 'Strong_Bond';
            } else if (distance <= sumRadii * 1.5) {
                return 'Weak_Bond';
            } else {
                return 'Non_Bond';
            }
        }



        function displayResults(bonds) {
            console.log('displayResults started:', bonds.length);
            if (!bonds || !Array.isArray(bonds)) {
                showError('Invalid result data.');
                return;
            }
            
            // Memory optimization: Store only essential bond data
            const optimizedBonds = bonds.map(bond => ({
                id: bond.id,
                duplicated: bond.duplicated,
                atom1: bond.atom1,
                atom2: bond.atom2,
                atom1Coords: bond.atom1Coords,
                atom2Coords: bond.atom2Coords,
                distance: bond.distance,
                relativePosition: bond.relativePosition,
                bondVector: bond.bondVector,
                bondType: bond.bondType,
                uniqueID: bond.uniqueID,
                unique: bond.unique
            }));
            
            // Save maxUniqueID for all bonds and unique bonds (for unique-only toggle)
            maxUIDAllBonds = calculateMaxUIDForDisplay(optimizedBonds, 200);
            const uniqueBonds = optimizedBonds.filter(bond => bond.unique === 'T');
            maxUIDUniqueBonds = calculateMaxUIDForDisplay(uniqueBonds, 200);
            console.log('maxUIDAllBonds:', maxUIDAllBonds, 'maxUIDUniqueBonds:', maxUIDUniqueBonds);
            
            // Note: Using UID-based filtering with ID-order display for better duplicate pair visibility
            
            // Update memory usage tracking
            memoryUsage.bondDataSize = optimizedBonds.length;
            
            // Stop spinner first
            const resultsDiv = document.getElementById('results');
            const spinner = resultsDiv.querySelector('.spinner');
            if (spinner) {
                spinner.remove();
            }
            
            // Show bond list area
            const bondList = document.getElementById('bondList');
            const downloadBtn = document.getElementById('downloadBtn');
            
            console.log('resultsDiv:', resultsDiv);
            console.log('bondList:', bondList);
            console.log('downloadBtn:', downloadBtn);
            
            if (!resultsDiv) {
                showError('Result display area not found.');
                return;
            }
            
            if (!bondList) {
                showError('Bond list area not found.');
                return;
            }
            
            // Show bond results title and list area
            const bondResultsTitle = document.getElementById('bondResultsTitle');
            if (bondResultsTitle) {
                bondResultsTitle.style.display = 'block';
            }
            
            // Show display controls
            const displayControls = document.getElementById('displayControls');
            if (displayControls) {
                displayControls.style.display = 'block';
            }
            
            // Update bond count info for initial display
            const bondCountInfo = document.getElementById('bondCountInfo');
            if (bondCountInfo) {
                const targetBondCount = 200;
                const maxUID = calculateMaxUIDForDisplay(optimizedBonds, targetBondCount);
                const displayBonds = optimizedBonds.filter(bond => bond.uniqueID <= maxUID);
                
                bondCountInfo.textContent = `(Showing ${displayBonds.length} bonds (UID ‚â§ ${maxUID}, sorted by ID) out of ${optimizedBonds.length} total)`;
            }
            
            bondList.style.display = 'block';
            
            // Clear and add header
            addBondListHeader(bondList);
            
            if (optimizedBonds.length === 0) {
                bondList.innerHTML += `
                    <div class="bond-item">
                        <div colspan="9" style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                            <p style="margin: 0; font-size: 1.1em;">üîç No bonds found matching the specified conditions.</p>
                            <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #999;">Try adjusting the distance range or atom selection.</p>
                        </div>
                    </div>
                `;
                if (downloadBtn) {
                    downloadBtn.style.display = 'none';
                }
            } else {
                // Filter by Unique ID but display in ID order (distance order)
                const targetBondCount = 200;
                const maxUID = calculateMaxUIDForDisplay(optimizedBonds, targetBondCount);
                const filteredBonds = optimizedBonds.filter(bond => bond.uniqueID <= maxUID);
                // Sort by ID (distance order) for display
                const displayBonds = filteredBonds.sort((a, b) => a.id - b.id);
                
                console.log(`Displaying bonds with UID <= ${maxUID}, sorted by ID, showing ${displayBonds.length} bonds out of ${optimizedBonds.length} total`);
                
                displayBonds.forEach((bond, index) => {
                    const isDuplicated = bond.duplicated === 'T';
                    const cellStyle = isDuplicated ? 'background-color: #e8e8e8;' : '';
                    
                    bondList.innerHTML += `
                        <div class="bond-item" style="${cellStyle}">
                            <div><small>${bond.id || 'N/A'}</small></div>
                            <div>${bond.atom1}<br><small style="color: #666;">${bond.atom1Coords}</small></div>
                            <div>${bond.atom2}<br><small style="color: #666;">${bond.atom2Coords}</small></div>
                            <div class="distance">${bond.distance.toFixed(3)}</div>
                            <div><small>${bond.relativePosition}</small></div>
                            <div><small>${bond.bondVector}</small></div>
                            <div><small>${bond.bondType}</small></div>
                            <div><small>${bond.uniqueID || 'N/A'}</small></div>
                            <div><small style="color: ${bond.unique === 'T' ? '#27ae60' : '#e67e22'}; font-weight: bold;">${bond.unique || 'N/A'}</small></div>
                        </div>
                    `;
                });
                
                // Add: Show warning from the first time if over 200 items
                insertBondWarningIfNeeded(optimizedBonds.length);
                
                if (downloadBtn) {
                    downloadBtn.style.display = 'block';
                }
            }
            
            console.log('display processing completed');
            
            // Add result display completion message
            postProgressMessage(`üìä Result display complete: Displayed ${bonds.length} bonds`);
            
            // Final completion message
            setTimeout(() => {
                postProgressMessage(`üéâ Process complete: All processing completed successfully`);
                
                // Update search status title to completed
                updateSearchStatusTitle('completed', `${bonds.length} bonds found`);
                
                // Re-attach event listener for the toggle after results are displayed
                const uniqueOnlyToggle = document.getElementById('uniqueOnlyToggle');
                if (uniqueOnlyToggle) {
                    // Remove existing listener to avoid duplicates
                    uniqueOnlyToggle.removeEventListener('change', updateBondDisplay);
                    uniqueOnlyToggle.addEventListener('change', function() {
                        console.log('Toggle changed in displayResults:', this.checked);
                        updateBondDisplay();
                    });
                }
            }, 200);
            
            // display resultsDiv
            const finalResultsDiv = document.getElementById('results');
            if (finalResultsDiv) {
                finalResultsDiv.style.display = 'block';
            }
            
            console.log('before showInfo');
            showInfo(`${optimizedBonds.length} bonds found.`);
            console.log('after showInfo');
        }

        function showLoading() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'block';
            
            // Reset to initial state
            resultsDiv.innerHTML = `
                <h3 id="searchStatusTitle">üîç Search in progress... <div class="spinner-small" style="display: inline-block; margin-left: 10px;"></div></h3>
                <div id="searchStopInfo" style="margin-bottom: 15px; color: #666; font-size: 0.9em;">
                    ‚èπÔ∏è Stop: Can be stopped with "Stop Search" button or Esc key
                </div>
                <div id="progressMessages" style="max-height: 200px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; border: 1px solid #ddd; margin-bottom: 20px; display: none;">
                </div>
                <h4 id="bondResultsTitle" style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #4facfe; padding-bottom: 5px; display: none;">
                    üìä Bond Analysis Results
                </h4>
                <div id="displayControls" style="margin-bottom: 15px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; background: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
                        <label for="uniqueOnlyToggle" style="font-weight: 600; color: #333; margin: 0;">
                            <input type="checkbox" id="uniqueOnlyToggle" style="margin-right: 8px; transform: scale(1.2);">
                            Show unique bonds only
                        </label>
                        <span id="bondCountInfo" style="color: #666; font-size: 0.9em; margin-left: 10px;">
                            (Showing all bonds)
                        </span>
                    </div>
                </div>
                <div id="bondList" class="bond-list"></div>
                <button id="downloadBtn" class="download-btn" onclick="downloadResults()" style="display: none;">
                    üíæ Download Results (CSV)
                </button>
            `;
        }



        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `<strong>Error:</strong> ${message}`;
            
            const mainContent = document.querySelector('.main-content');
            mainContent.insertBefore(errorDiv, mainContent.firstChild);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function showInfo(message) {
            const infoDiv = document.createElement('div');
            infoDiv.className = 'info';
            infoDiv.innerHTML = `<strong>Info:</strong> ${message}`;
            
            const mainContent = document.querySelector('.main-content');
            mainContent.insertBefore(infoDiv, mainContent.firstChild);
            
            setTimeout(() => {
                infoDiv.remove();
            }, 5000);
        }

        // function for file parsing log
        function addParseLog(message, type = 'info') {
            const logContainer = document.getElementById('parseLogMessages');
            const fileParseLog = document.getElementById('fileParseLog');
            
            if (!logContainer) {
                console.error('parseLogMessages element not found');
                return;
            }
            
            // Display log area
            fileParseLog.style.display = 'block';
            
            const logDiv = document.createElement('div');
            logDiv.className = 'progress-message';
            
            // set icon according to type
            let icon = '‚ÑπÔ∏è';
            if (type === 'success') icon = '‚úÖ';
            else if (type === 'warning') icon = '‚ö†Ô∏è';
            else if (type === 'error') icon = '‚ùå';
            
            logDiv.innerHTML = `${icon} ${message}`;
            
            logContainer.appendChild(logDiv);
            
            // scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
            
            console.log(`[ParseLog] ${message}`);
        }

        // function to clear file parsing log
        function clearParseLog() {
            const logContainer = document.getElementById('parseLogMessages');
            if (logContainer) {
                logContainer.innerHTML = '';
            }
            const fileParseLog = document.getElementById('fileParseLog');
            if (fileParseLog) {
                fileParseLog.style.display = 'none';
            }
        }

        function stopSearch() {
            if (currentWorker) {
                currentWorker.terminate();
                currentWorker = null;
            }
            
            isSearching = false;
            updateSearchButtons();
            
            // Memory cleanup on stop
            cleanupMemory();
            
            // Stop spinner first
            const resultsDiv = document.getElementById('results');
            const spinner = resultsDiv.querySelector('.spinner');
            if (spinner) {
                spinner.remove();
            }
            
            // Display stop message
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <h3 id="searchStatusTitle">‚èπÔ∏è Search stopped</h3>
                <div id="progressMessages" style="max-height: 200px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; border: 1px solid #ddd; margin-bottom: 20px;">
                    <div class="info" style="margin: 0;">
                        <strong>Info:</strong> Search was manually stopped. Please adjust conditions and re-run as needed.
                    </div>
                </div>
                <h4 id="bondResultsTitle" style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #4facfe; padding-bottom: 5px; display: none;">
                    üìä Bond Analysis Results
                </h4>
                <div id="displayControls" style="margin-bottom: 15px; display: none;">
                    <div style="display: flex; align-items: center; gap: 10px; background: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
                        <label for="uniqueOnlyToggle" style="font-weight: 600; color: #333; margin: 0;">
                            <input type="checkbox" id="uniqueOnlyToggle" style="margin-right: 8px; transform: scale(1.2);">
                            Show unique bonds only
                        </label>
                        <span id="bondCountInfo" style="color: #666; font-size: 0.9em; margin-left: 10px;">
                            (Showing all bonds)
                        </span>
                    </div>
                </div>
                <div id="bondList" class="bond-list"></div>
                <button id="downloadBtn" class="download-btn" onclick="downloadResults()" style="display: none;">
                    üíæ Download Results (CSV)
                </button>
            `;
            
            // Update search status title
            updateSearchStatusTitle('stopped');
            
            // Re-attach event listener for the toggle
            const uniqueOnlyToggle = document.getElementById('uniqueOnlyToggle');
            if (uniqueOnlyToggle) {
                // Remove existing listener to avoid duplicates
                uniqueOnlyToggle.removeEventListener('change', updateBondDisplay);
                uniqueOnlyToggle.addEventListener('change', function() {
                    console.log('Toggle changed in stopSearch:', this.checked);
                    updateBondDisplay();
                });
            }
            
            showInfo('Search stopped.');
        }

        function updateSearchButtons() {
            const searchBtn = document.getElementById('searchBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (isSearching) {
                searchBtn.style.display = 'none';
                stopBtn.style.display = 'block';
            } else {
                searchBtn.style.display = 'block';
                stopBtn.style.display = 'none';
            }
        }

        function updateSearchStatusTitle(status, message = '') {
            const statusTitle = document.getElementById('searchStatusTitle');
            const searchStopInfo = document.getElementById('searchStopInfo');
            
            if (statusTitle) {
                switch (status) {
                    case 'searching':
                        statusTitle.innerHTML = 'üîç Search in progress... <div class="spinner-small" style="display: inline-block; margin-left: 10px;"></div>';
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'block';
                        }
                        break;
                    case 'completed':
                        statusTitle.innerHTML = `‚úÖ Search completed - ${message}`;
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'none';
                        }
                        break;
                    case 'stopped':
                        statusTitle.innerHTML = '‚èπÔ∏è Search stopped';
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'none';
                        }
                        break;
                    case 'error':
                        statusTitle.innerHTML = '‚ùå Search error';
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'none';
                        }
                        break;
                    default:
                        statusTitle.innerHTML = 'üîç Search in progress... <div class="spinner-small" style="display: inline-block; margin-left: 10px;"></div>';
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'block';
                        }
                }
            }
        }

        function updateProgressMessage(message) {
            try {
                const resultsDiv = document.getElementById('results');
                if (!resultsDiv) {
                    console.error('resultsDiv not found');
                    return;
                }
                
                if (resultsDiv.style.display === 'none') {
                    resultsDiv.style.display = 'block';
                }
                
                // Show progress messages area and add message
                const progressDiv = document.getElementById('progressMessages');
                if (!progressDiv) {
                    console.error('progressMessages element not found');
                    return;
                }
                
                // Show progress messages area
                progressDiv.style.display = 'block';
                
                // add progress message to existing one
                const messageDiv = document.createElement('div');
                messageDiv.className = 'progress-message';
                messageDiv.textContent = message;
                progressDiv.appendChild(messageDiv);
                
                // scroll to bottom
                progressDiv.scrollTop = progressDiv.scrollHeight;
                
                // Hide stop info when search is complete
                if (message.includes('Complete:') || message.includes('complete')) {
                    setTimeout(() => {
                        const searchStopInfo = document.getElementById('searchStopInfo');
                        if (searchStopInfo) {
                            searchStopInfo.style.display = 'none';
                        }
                    }, 1000); // Hide after 1 second
                }
            } catch (error) {
                console.error('error in updateProgressMessage:', error);
            }
        }



        // function to download results (optimized)
        async function downloadResults() {
            if (!currentBonds || currentBonds.length === 0) {
                showError('No results to download.');
                return;
            }

            // CSV header (English)
            let csvContent = 'ID,Duplicated,Atom1,Atom1_Coordinates,Atom2,Atom2_Coordinates,Distance_A,Relative_Position,Bond_Vector,Bond_Type,Unique_ID,Unique\n';
            
            // Optimized data processing with chunking for large datasets
            const chunkSize = 1000;
            const totalBonds = currentBonds.length;
            
            // Process in chunks to avoid memory issues
            for (let i = 0; i < totalBonds; i += chunkSize) {
                const chunk = currentBonds.slice(i, i + chunkSize);
                
                chunk.forEach(bond => {
                    const row = [
                        bond.id || '',
                        bond.duplicated || '',
                        bond.atom1,
                        bond.atom1Coords,
                        bond.atom2,
                        bond.atom2Coords,
                        bond.distance.toFixed(3),
                        bond.relativePosition,
                        bond.bondVector,
                        bond.bondType,
                        bond.uniqueID || '',
                        bond.unique || ''
                    ].map(field => `"${field}"`).join(',');
                    csvContent += row + '\n';
                });
                
                // Allow UI updates between chunks
                if (i + chunkSize < totalBonds) {
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            // Generate filename (including current date and time)
            const now = new Date();
            const timestamp = now.getFullYear() + 
                            String(now.getMonth() + 1).padStart(2, '0') + 
                            String(now.getDate()).padStart(2, '0') + '_' +
                            String(now.getHours()).padStart(2, '0') + 
                            String(now.getMinutes()).padStart(2, '0');
            
            const filename = `bonding_results_${timestamp}.csv`;

            // Download processing
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showInfo(`Results downloaded as ${filename}.`);
            } else {
                showError('Your browser does not support download functionality.');
            }
        }

        // function to get symmetry operations from embedded space group data
        function getSymmetryOperationsFromEmbeddedData(spaceGroupNumber) {
            if (typeof embeddedSpaceGroupData !== 'undefined' && embeddedSpaceGroupData[spaceGroupNumber]) {
                return embeddedSpaceGroupData[spaceGroupNumber].symmetry_operations;
            }
            return null;
        }

        // function to get symmetry operations from space group number (using embedded data only)
        async function getSymmetryOperationsBySpaceGroupNumber(spaceGroupNumber) {
            console.log(`Getting symmetry operations from space group number ${spaceGroupNumber}...`);
            
            // Check embedded data
            const embeddedOps = getSymmetryOperationsFromEmbeddedData(spaceGroupNumber);
            if (embeddedOps && embeddedOps.length > 0) {
                console.log(`Retrieved symmetry operations for space group ${spaceGroupNumber} from embedded data: ${embeddedOps.length} items`);
                return embeddedOps;
            }
            
            // If not in embedded data
            throw new Error(`Symmetry operation data for space group ${spaceGroupNumber} is not included in embedded data`);
        }

        // Function to display version information
        function showVersionInfo() {
            const versionInfo = `${APP_NAME} v${APP_VERSION}`;
            console.log(versionInfo);
            showInfo(versionInfo);
        }

        // Function to get version information
        function getVersionInfo() {
            return {
                name: APP_NAME,
                version: APP_VERSION,
                description: APP_DESCRIPTION
            };
        }

        // Function to calculate max unique ID for displaying approximately target number of bonds
        function calculateMaxUIDForDisplay(bonds, targetCount) {
            if (!bonds || bonds.length === 0) return 0;
            
            // Count bonds by unique ID
            const bondsByUID = new Map();
            bonds.forEach(bond => {
                const id = bond.uniqueID || 0;
                bondsByUID.set(id, (bondsByUID.get(id) || 0) + 1);
            });
            
            // Sort unique IDs
            const sortedUIDs = Array.from(bondsByUID.keys()).sort((a, b) => a - b);
            
            // Step 1: Initialize NumDisplayTotal
            let NumDisplayTotal = 0;
            let maxUID = 0;
            
            // Step 2-4: Process each UID sequentially
            for (const uid of sortedUIDs) {
                const bondsInThisUID = bondsByUID.get(uid);
                NumDisplayTotal += bondsInThisUID;
                
                // Step 3: Check if exceeding target
                if (NumDisplayTotal > targetCount) {
                    // Step 4: Set maxUID to previous UID
                    maxUID = uid - 1;
                    break;
                } else {
                    maxUID = uid;
                }
            }
            
            // Step 5: Ensure at least one bond is displayed if any exist
            if (maxUID === 0 && sortedUIDs.length > 0) {
                // If less than 200, return the maximum unique ID value
                maxUID = Math.max(...sortedUIDs);
            }
            
            // Calculate actual bonds in range for logging
            const actualBondsInRange = bonds.filter(bond => bond.uniqueID <= maxUID).length;
            
            console.log(`Target: ${targetCount}, Max UID: ${maxUID}, Bonds in range: ${actualBondsInRange}, Total bonds: ${bonds.length}`);
            return maxUID;
        }

        // Function to update bond display based on toggle state
        function updateBondDisplay() {
            console.log('updateBondDisplay called');
            const uniqueOnlyToggle = document.getElementById('uniqueOnlyToggle');
            const bondCountInfo = document.getElementById('bondCountInfo');
            const bondList = document.getElementById('bondList');
            
            console.log('uniqueOnlyToggle:', uniqueOnlyToggle);
            console.log('currentBonds:', currentBonds);
            console.log('currentBonds length:', currentBonds ? currentBonds.length : 'undefined');
            
            if (!uniqueOnlyToggle || !currentBonds || currentBonds.length === 0) {
                console.log('Early return: missing elements or no bonds');
                return;
            }
            
            const showUniqueOnly = uniqueOnlyToggle.checked;
            console.log('showUniqueOnly:', showUniqueOnly);
            
            const filteredBonds = showUniqueOnly ? 
                currentBonds.filter(bond => bond.unique === 'T') : 
                currentBonds;
            insertBondWarningIfNeeded(filteredBonds.length, showUniqueOnly);
            
            console.log('filteredBonds length:', filteredBonds.length);
            console.log('Sample bonds:', currentBonds.slice(0, 3).map(b => ({ atom1: b.atom1, atom2: b.atom2, unique: b.unique })));
            
            // Update count info
            if (bondCountInfo) {
                if (showUniqueOnly) {
                    // For unique-only mode, use UID-based filtering
                    const maxUID = maxUIDUniqueBonds;
                    const displayBonds = filteredBonds.filter(bond => bond.uniqueID <= maxUID);
                    bondCountInfo.textContent = `(Showing ${displayBonds.length} unique bonds (UID ‚â§ ${maxUID}) out of ${filteredBonds.length} unique, ${currentBonds.length} total)`;
                } else {
                    // For all bonds mode, use UID-based filtering but display in ID order
                    const maxUID = maxUIDAllBonds;
                    const displayBonds = filteredBonds.filter(bond => bond.uniqueID <= maxUID);
                    bondCountInfo.textContent = `(Showing ${displayBonds.length} bonds (UID ‚â§ ${maxUID}, sorted by ID) out of ${currentBonds.length} total)`;
                }
            }
            
            // Re-render bond list
            if (bondList) {
                bondList.innerHTML = '';
                addBondListHeader(bondList);
                // Add data rows below
                if (filteredBonds.length === 0) {
                    bondList.innerHTML += `
                        <div class="bond-item">
                            <div colspan="9" style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                                <p style="margin: 0; font-size: 1.1em;">üîç No unique bonds found.</p>
                                <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #999;">All bonds are equivalent to others.</p>
                            </div>
                        </div>
                    `;
                } else {
                    // Use appropriate filtering based on mode
                    let displayBonds;
                    if (showUniqueOnly) {
                        // For unique-only mode, use UID-based filtering
                        const maxUID = maxUIDUniqueBonds;
                        displayBonds = filteredBonds.filter(bond => bond.uniqueID <= maxUID);
                        console.log(`Displaying unique bonds with UID <= ${maxUID}, showing ${displayBonds.length} bonds out of ${filteredBonds.length} total unique bonds`);
                    } else {
                        // For all bonds mode, use UID-based filtering but display in ID order
                        const maxUID = maxUIDAllBonds;
                        const filteredByUID = filteredBonds.filter(bond => bond.uniqueID <= maxUID);
                        // Sort by ID (distance order) for display
                        displayBonds = filteredByUID.sort((a, b) => a.id - b.id);
                        console.log(`Displaying bonds with UID <= ${maxUID}, sorted by ID, showing ${displayBonds.length} bonds out of ${currentBonds.length} total bonds`);
                    }
                    displayBonds.forEach((bond, index) => {
                        const isDuplicated = bond.duplicated === 'T';
                        const cellStyle = isDuplicated ? 'background-color: #e8e8e8;' : '';
                        
                        bondList.innerHTML += `
                            <div class="bond-item" style="${cellStyle}">
                                <div><small>${bond.id || 'N/A'}</small></div>
                                <div>${bond.atom1}<br><small style="color: #666;">${bond.atom1Coords}</small></div>
                                <div>${bond.atom2}<br><small style="color: #666;">${bond.atom2Coords}</small></div>
                                <div class="distance">${bond.distance.toFixed(3)}</div>
                                <div><small>${bond.relativePosition}</small></div>
                                <div><small>${bond.bondVector}</small></div>
                                <div><small>${bond.bondType}</small></div>
                                <div><small>${bond.uniqueID || 'N/A'}</small></div>
                                <div><small style="color: ${bond.unique === 'T' ? '#27ae60' : '#e67e22'}; font-weight: bold;">${bond.unique || 'N/A'}</small></div>
                            </div>
                        `;
                    });
                    
                    // Add: Show warning from the first time if over 200 items (not unique display, so false)
                    insertBondWarningIfNeeded(filteredBonds.length, showUniqueOnly);
                }
            }
        }

        // Function to extract base atom name (remove _sym{i} suffix)
        function getBaseAtomName(atomLabel) {
            return atomLabel.replace(/_sym\d+$/, '');
        }

        // Function to check if two bond vectors are opposite (within numerical tolerance)
        function checkOppositeBondVectors(vector1Str, vector2Str, tolerance = 1e-4) {
            try {
                // Parse bond vector strings: "(dx, dy, dz)" -> [dx, dy, dz]
                const parseVector = (vectorStr) => {
                    // Remove parentheses and split by commas
                    const cleaned = vectorStr.replace(/[()]/g, '').trim();
                    const components = cleaned.split(',').map(comp => parseFloat(comp.trim()));
                    
                    if (components.length !== 3 || components.some(comp => isNaN(comp))) {
                        throw new Error(`Invalid vector format: ${vectorStr}`);
                    }
                    
                    return components;
                };
                
                const vec1 = parseVector(vector1Str);
                const vec2 = parseVector(vector2Str);
                
                console.log(`  Comparing vectors: ${vector1Str} vs ${vector2Str}`);
                console.log(`  Parsed: [${vec1.join(', ')}] vs [${vec2.join(', ')}]`);
                
                // Check if vec2 ‚âà -vec1 (within tolerance)
                const isOpposite = vec1.every((comp1, index) => {
                    const comp2 = vec2[index];
                    const opposite = -comp1;
                    const diff = Math.abs(comp2 - opposite);
                    const isWithinTolerance = diff <= tolerance;
                    
                    console.log(`  Component ${index}: ${comp1} vs ${comp2}, expected opposite: ${opposite}, diff: ${diff.toExponential(3)}, within tolerance: ${isWithinTolerance}`);
                    
                    return isWithinTolerance;
                });
                
                console.log(`  Vectors are opposite: ${isOpposite}`);
                return isOpposite;
                
            } catch (error) {
                console.error(`Error checking opposite bond vectors: ${error.message}`);
                console.error(`Vector1: "${vector1Str}", Vector2: "${vector2Str}"`);
                return false; // If parsing fails, assume not opposite
            }
        }

        // Function to determine bond equivalence and assign identifiers
        function assignBondIdentifiers(bonds) {
            console.log('=== Starting bond equivalence analysis ===');
            
            // Step 1: Sort bonds by distance (shortest first)
            const sortedBonds = [...bonds].sort((a, b) => a.distance - b.distance);
            console.log(`Step 1: Sorted ${sortedBonds.length} bonds by distance`);
            
            // Step 2: Assign sequential IDs and detect duplicated bonds
            const bondPairMap = new Map(); // Key: exact atom pair + distance, Value: array of bond info
            let nextID = 1;
            
            const bondsWithID = sortedBonds.map((bond, index) => {
                const distanceKey = Math.round(bond.distance * 1000) / 1000;
                const exactPairKey = `${bond.atom1}|${bond.atom2}|${distanceKey}`;
                const reversePairKey = `${bond.atom2}|${bond.atom1}|${distanceKey}`;
                
                const bondWithID = {
                    ...bond,
                    id: nextID,
                    duplicated: 'F'
                };
                
                // Check for reverse bonds (A-B vs B-A case)
                const reverseMatches = bondPairMap.get(reversePairKey) || [];
                let foundReversePair = false;
                
                for (const existingBond of reverseMatches) {
                    if (checkOppositeBondVectors(bond.bondVector, existingBond.bondVector)) {
                        // Found a reverse pair with opposite bond vector
                        bondWithID.id = existingBond.id; // Use the same ID
                        bondWithID.duplicated = 'T'; // Mark as duplicated
                        foundReversePair = true;
                        console.log(`Found reverse pair: ${bond.atom1}-${bond.atom2} (ID: ${bondWithID.id}) is duplicate of ${existingBond.atom1}-${existingBond.atom2}`);
                        break;
                    }
                }
                
                if (!foundReversePair) {
                    // Register this bond for future reverse lookup
                    const bondInfo = {
                        id: nextID,
                        atom1: bond.atom1,
                        atom2: bond.atom2,
                        bondVector: bond.bondVector
                    };
                    
                    if (!bondPairMap.has(exactPairKey)) {
                        bondPairMap.set(exactPairKey, []);
                    }
                    bondPairMap.get(exactPairKey).push(bondInfo);
                    
                    nextID++; // Increment ID only for non-duplicated bonds
                }
                
                return bondWithID;
            });
            
            console.log(`Step 2: Assigned IDs and duplicated flags. Total unique IDs: ${nextID - 1}`);
            
            // Step 3: Sort by ID, with Duplicated=F bonds coming first within each ID group
            bondsWithID.sort((a, b) => {
                if (a.id !== b.id) {
                    return a.id - b.id; // Sort by ID first
                }
                // Within same ID, put Duplicated=F before Duplicated=T
                if (a.duplicated === 'F' && b.duplicated === 'T') return -1;
                if (a.duplicated === 'T' && b.duplicated === 'F') return 1;
                return 0;
            });
            
            console.log(`Step 3: Sorted by ID with Duplicated=F bonds first`);
            
            // Step 4: Assign Unique IDs and unique flags (chemical equivalence)
            // Rule 1: Group by BaseAtomName combination + distance
            // Rule 2: Within each group, smallest ID with Duplicated=F gets Unique=T
            // Rule 3: All groups get sequential UniqueID (1, 2, 3, ...)
            
            const bondGroups = new Map();
            
            // Group bonds by equivalence rules (OR condition)
            // Rule 1: Same ID ‚Üí Same group
            // Rule 2: Same BaseAtomName combination + Same distance ‚Üí Same group
            bondsWithID.forEach((bond, index) => {
                const baseAtom1 = getBaseAtomName(bond.atom1);
                const baseAtom2 = getBaseAtomName(bond.atom2);
                const distanceKey = Math.round(bond.distance * 1000) / 1000;
                const chemicalKey = `${baseAtom1}|${baseAtom2}|${distanceKey}`;
                
                let targetGroup = null;
                let targetKey = null;
                
                // Rule 1: Check if any existing group contains the same ID
                for (const [key, group] of bondGroups) {
                    if (group.some(item => item.bond.id === bond.id)) {
                        targetGroup = group;
                        targetKey = key;
                        console.log(`Bond ${bond.id} matched existing group by ID: ${key}`);
                        break;
                    }
                }
                
                // Rule 2: If no ID match, check for chemical equivalence
                if (!targetGroup) {
                    for (const [key, group] of bondGroups) {
                        // Extract chemical part from existing group (skip any prefix)
                        const existingBond = group[0].bond;
                        const existingBaseAtom1 = getBaseAtomName(existingBond.atom1);
                        const existingBaseAtom2 = getBaseAtomName(existingBond.atom2);
                        const existingDistanceKey = Math.round(existingBond.distance * 1000) / 1000;
                        const existingChemicalKey = `${existingBaseAtom1}|${existingBaseAtom2}|${existingDistanceKey}`;
                        
                        if (existingChemicalKey === chemicalKey) {
                            targetGroup = group;
                            targetKey = key;
                            console.log(`Bond ${bond.id} matched existing group by chemistry: ${key}`);
                            break;
                        }
                    }
                }
                
                // Create new group if no match found
                if (!targetGroup) {
                    targetKey = chemicalKey;
                    bondGroups.set(targetKey, []);
                    targetGroup = bondGroups.get(targetKey);
                    console.log(`Bond ${bond.id} created new group: ${targetKey}`);
                }
                
                targetGroup.push({ bond, index });
            });
            
            // Assign UniqueIDs sequentially and determine unique representatives
            let uniqueID = 1;
            const finalBonds = [...bondsWithID]; // Copy array
            let uniqueCount = 0;
            
            bondGroups.forEach((groupBonds, equivalenceKey) => {
                console.log(`Processing group ${uniqueID} (${equivalenceKey}) with ${groupBonds.length} bonds`);
                
                // Find the bond with smallest ID and Duplicated=F
                let uniqueRepresentative = null;
                let smallestID = Infinity;
                
                for (const {bond, index} of groupBonds) {
                    if (bond.duplicated === 'F' && bond.id < smallestID) {
                        smallestID = bond.id;
                        uniqueRepresentative = index;
                    }
                }
                
                // Assign UniqueID and unique flags to all bonds in this group
                for (const {bond, index} of groupBonds) {
                    finalBonds[index] = {
                        ...bond,
                        uniqueID: uniqueID,
                        unique: (index === uniqueRepresentative) ? 'T' : 'F'
                    };
                }
                
                if (uniqueRepresentative !== null) {
                    uniqueCount++;
                    console.log(`  ‚Üí UniqueID ${uniqueID}: Representative at index ${uniqueRepresentative}, ID ${finalBonds[uniqueRepresentative].id}`);
                } else {
                    console.log(`  ‚Üí UniqueID ${uniqueID}: No representative (all Duplicated=T)`);
                }
                
                uniqueID++;
            });
            
            console.log(`Step 4: Assigned Unique IDs and unique flags`);
            
            // Calculate maxUIDAllBonds for display control
            if (finalBonds.length > 0) {
                maxUIDAllBonds = Math.max(...finalBonds.map(bond => bond.uniqueID));
                console.log(`maxUIDAllBonds set to: ${maxUIDAllBonds}`);
            }
            
            console.log(`=== Bond equivalence analysis complete ===`);
            console.log(`Total bonds: ${bonds.length}`);
            console.log(`Chemical equivalent groups: ${bondGroups.size}`);
            console.log(`Groups with Unique=T representatives: ${uniqueCount}`);
            console.log(`Groups without representatives (all Duplicated=T): ${bondGroups.size - uniqueCount}`);
            console.log(`Sequential IDs assigned: ${nextID - 1}`);
            console.log(`Unique IDs assigned: ${uniqueID - 1}`);
            console.log(`Duplicated bonds: ${finalBonds.filter(b => b.duplicated === 'T').length}`);
            console.log(`Unique representatives: ${finalBonds.filter(b => b.unique === 'T').length}`);
            
            return finalBonds;
        }

        // Function to insert/delete warning text
        function insertBondWarningIfNeeded(bondCount, isUniqueMode) {
            // Delete existing warning text
            const oldWarning = document.getElementById('bondWarningBox');
            if (oldWarning) oldWarning.remove();
            if (bondCount <= 200) return;
            const bondList = document.getElementById('bondList');
            if (!bondList) return;
            const warningBox = document.createElement('div');
            warningBox.id = 'bondWarningBox';
            warningBox.style.background = '#fff3cd';
            warningBox.style.borderLeft = '4px solid #ffc107';
            warningBox.style.margin = '0 0 15px 0';
            warningBox.style.borderRadius = '5px';
            let mainMsg = isUniqueMode
                ? '‚ö†Ô∏è Too many unique bonds have been detected. Not all unique bonds are displayed to reduce the load.'
                : '‚ö†Ô∏è Too many bonds have been detected. Not all of them are displayed to reduce the load.';
            warningBox.innerHTML = `
                <div style="text-align: center; color: #856404; padding: 15px;">
                    <p style="margin: 0; font-size: 1em;">${mainMsg}</p>
                    <p style="margin: 5px 0 0 0; font-size: 0.9em;">Use the download button to get all results</p>
                </div>
            `;
            bondList.insertAdjacentElement('beforebegin', warningBox);
        }

        function addBondListHeader(bondList) {
            if (!bondList) return;
            bondList.innerHTML += `
                <div class="bond-item bond-header">
                    <div>ID</div>
                    <div>Atom 1<br><small>Coordinates</small></div>
                    <div>Atom 2<br><small>Coordinates</small></div>
                    <div>Distance<br><small>(√Ö)</small></div>
                    <div>Relative Position<br><small>(i,j,k)</small></div>
                    <div>Bond Vector</div>
                    <div>Bond Type</div>
                    <div>Unique ID</div>
                    <div>Unique</div>
                </div>
            `;
        }

    </script>
    
    <!-- embedded space group data -->
    <script src="./embedded_spacegroups.js"></script>
</body>
</html> 
</html> 